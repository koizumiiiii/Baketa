# C# コーディング標準規約 - パフォーマンス最適化ガイドライン

このドキュメントでは、Baketaプロジェクトにおけるパフォーマンス最適化のためのガイドラインを提供します。ゲーム翻訳オーバーレイアプリケーションはリソース使用に敏感であるため、これらのガイドラインに従ってリソース効率の高いコードを作成することが重要です。

> **関連ドキュメント**:
> - [基本原則](./csharp-standards.md)
> - [モダンC#機能の活用](./modern-csharp.md)
> - [Windows相互運用ガイドライン](./platform-interop.md)
> - [Avalonia UIガイドライン](../../../3-architecture/ui-system/avalonia-guidelines.md)

## 目次

1. [静的メソッドの活用](#1-静的メソッドの活用)
2. [メモリ管理の最適化](#2-メモリ管理の最適化)
3. [非同期プログラミングのパフォーマンス](#3-非同期プログラミングのパフォーマンス)
4. [キャッシュの効果的な利用](#4-キャッシュの効果的な利用)
5. [LINQ最適化](#5-linq最適化)
6. [差分検出アルゴリズムの最適化](#6-差分検出アルゴリズムの最適化)
7. [画像処理の最適化](#7-画像処理の最適化)
8. [ログとトレースのパフォーマンス影響](#8-ログとトレースのパフォーマンス影響)

## 1. 静的メソッドの活用

### 1.1 インスタンスデータにアクセスしないメソッドの静的化 (CA1822)

インスタンスフィールドやプロパティにアクセスしないメソッドは、静的メソッドとして宣言します：

```csharp
// ❌ 避けるべき書き方
public void FormatText(string text)
{
    // インスタンスデータにアクセスしていない処理
}

// ✅ 推奨される書き方
public static void FormatText(string text)
{
    // 静的メソッドとして宣言
}
```

### 1.2 静的なキャッシュとリソース共有

複数のインスタンス間で共有できるリソースは静的フィールドを使用します：

```csharp
// ❌ 避けるべき書き方 - インスタンスごとに作成されてメモリを消費
public class TranslationService
{
    private readonly Dictionary<string, string> _commonPhrases = new Dictionary<string, string>
    {
        ["Hello"] = "こんにちは",
        ["Thank you"] = "ありがとう",
        // 多数の共通フレーズ...
    };
}

// ✅ 推奨される書き方 - すべてのインスタンス間で共有
public class TranslationService
{
    private static readonly IReadOnlyDictionary<string, string> CommonPhrases = new Dictionary<string, string>
    {
        ["Hello"] = "こんにちは",
        ["Thank you"] = "ありがとう",
        // 多数の共通フレーズ...
    };
}
```

### 1.3 配列の再利用 (CA1861)

同じ配列が繰り返し使用される場合、これを静的読み取り専用フィールドとして宣言します。

## 2. メモリ管理の最適化

### 2.1 リソースの適切な解放

`IDisposable`を実装するクラスでは、確実にリソースを解放します。

### 2.2 値型と参照型の適切な選択

小さいデータ構造には値型（struct）を使用し、大きなデータ構造や多態性が必要な場合は参照型（class）を使用します。

### 2.3 StringBuilder の適切な使用

文字列連結が多い場合は `StringBuilder` を使用します。

### 2.4 大きなオブジェクトの管理

大きなオブジェクトの作成・解放は計画的に行い、不要になったらすぐに解放します。

## 3. 非同期プログラミングのパフォーマンス

### 3.1 適切なTask.Runの使用

UI操作をブロックしないよう、CPU負荷の高い処理は `Task.Run` を使用して実行します。

### 3.2 ValueTaskの使用

頻繁に呼び出され、多くの場合同期的に完了するメソッドでは、`ValueTask<T>`を検討します。

### 3.3 非同期ストリームの活用

大量のデータを処理する場合、`IAsyncEnumerable<T>`を使用してメモリ使用量を最適化します。

## 4. キャッシュの効果的な利用

### 4.1 メモ化（計算結果のキャッシュ）

同じ入力に対して同じ結果を返す高コストな計算には、メモ化パターンを適用します。

### 4.2 メモリ消費とヒット率のバランス

キャッシュサイズとエントリの有効期限を調整して、メモリ使用とヒット率のバランスを取ります。

### 4.3 スレッドセーフなキャッシングパターン

キャッシュは常にスレッドセーフに実装します。

## 5. LINQ最適化

### 5.1 不要な列挙の回避

同じシーケンスに対して複数の操作を行う場合は、中間結果を変数に格納し、複数回の列挙を避けます。

### 5.2 早期終了の活用

完全な列挙が不要な場合は、`First()`, `Any()`, `Take()` などを使用して早期に終了します。

### 5.3 具体化のタイミングを最適化

LINQクエリの具体化（評価）を必要なタイミングで行います。

## 6. 差分検出アルゴリズムの最適化

OCRプロセスでは差分検出アルゴリズムが重要です。最適化のポイントは以下の通りです：

### 6.1 サンプリングと部分比較

画面全体を比較するのではなく、サンプリングポイントや重要な領域のみを比較します。

### 6.2 ヒストグラム比較の活用

個々のピクセルではなく、画像特性の比較にヒストグラムを使用します。

### 6.3 ハッシュベースの変更検出

画像の知覚ハッシュを使用して効率的に変更を検出します。

## 7. 画像処理の最適化

OCRと画像処理は計算負荷が高いため、最適化が重要です：

### 7.1 低レベルピクセルアクセス

`GetPixel`や`SetPixel`を避け、より高速な直接ピクセルデータアクセスを使用します。

### 7.2 並列処理の活用

画像処理タスクを並列化してマルチコアCPUを活用します。

### 7.3 リサイズと前処理の最適化

OCR処理の前にリサイズや前処理を行ってパフォーマンスを向上させます。

## 8. ログとトレースのパフォーマンス影響

### 8.1 条件付きロギングの使用

ログレベルの確認を先に行い、不要なログメッセージの構築を回避します：

```csharp
// ❌ 避けるべき書き方 - 常にメッセージを構築
_logger.LogDebug($"処理中: {item.Id}, 名前: {item.Name}, サイズ: {CalculateSize(item)}");

// ✅ 推奨される書き方 - 必要な場合のみメッセージを構築
if (_logger.IsEnabled(LogLevel.Debug))
{
    _logger.LogDebug("処理中: {Id}, 名前: {Name}, サイズ: {Size}", 
        item.Id, item.Name, CalculateSize(item));
}
```

### 8.2 ロギングの詳細度を実行時に制御

アプリケーションの動作中にロギングの詳細度を調整できるようにします。

### 8.3 高頻度のログ発生を回避

循環的またはループ内の高頻度のログ記録は避けます。

これらのガイドラインに従うことで、Baketaプロジェクトのパフォーマンスと応答性を大幅に向上させることができます。ゲームパフォーマンスに影響を与えないために、常にリソース使用量を意識したコーディングを心がけてください。