# OCR前処理システム要件定義と全体設計

*最終更新: 2025年4月24日*

## 1. 概要

OCR前処理システムは、Baketaアプリケーションにおけるテキスト認識精度向上のための中核コンポーネントです。ゲーム画面の多様な特性に対応し、OpenCVの画像処理機能を活用して最適な前処理パイプラインを提供します。本ドキュメントでは、OCR前処理システムの要件定義と全体アーキテクチャ設計について説明します。

## 2. 目的と背景

ゲーム画面でのテキスト認識は、以下の理由から単純なOCR処理では十分な精度を得ることが困難です：

1. **多様な背景**: ゲーム画面の複雑な背景がテキスト認識を妨げる
2. **フォントの多様性**: ゲーム固有のフォントやスタイルが標準的なOCRモデルとの相性が悪い
3. **画面の動的変化**: リアルタイムに変化する画面に対する処理の最適化が必要
4. **リソース制約**: ゲームプレイへの影響を最小限に抑えるためのパフォーマンス要件

これらの課題に対応するため、OpenCVを活用した体系的な前処理システムの構築が必要です。

## 3. 要件定義

### 3.1 機能要件

#### 3.1.1 基本画像処理機能

- **グレースケール変換**: カラー画像からグレースケール画像への変換
- **ノイズ除去**: ガウシアンフィルタなどによる画像ノイズの軽減
- **コントラスト強調**: ヒストグラム均一化などによる画像コントラストの改善
- **二値化処理**: 閾値処理による画像の二値化（固定閾値および適応的閾値）
- **モルフォロジー演算**: 膨張、収縮などの形状処理

#### 3.1.2 テキスト領域検出機能

- **MSERアルゴリズム**: Maximally Stable Extremal Regionsによるテキスト候補領域の検出
- **エッジベース検出**: エッジ検出と連結成分分析によるテキスト領域特定
- **テキスト領域フィルタリング**: サイズ、アスペクト比、位置などに基づくフィルタリング
- **領域の統合と分割**: 近接テキスト領域の統合と不適切な領域の分割

#### 3.1.3 差分検出機能

- **ヒストグラム比較**: 画面変化の効率的な検出
- **サンプリングベース検出**: 効率的なサンプリングによる高速差分検出
- **テキスト領域の変化検出**: テキスト領域に焦点を当てた変化検出
- **変化量に基づく処理制御**: 変化の大きさに応じた処理レベルの調整

#### 3.1.4 パイプライン構成機能

- **処理ステップの組み合わせ**: 複数の前処理ステップを柔軟に組み合わせる機能
- **パイプラインの動的構成**: 実行時にパイプラインの構成を変更する機能
- **パラメータの伝播**: パイプライン間でのパラメータの適切な伝播
- **パイプライン実行エンジン**: 前処理ステップを効率的に実行する機能

#### 3.1.5 プロファイル管理機能

- **ゲーム別プロファイル**: ゲームごとの最適パラメータを保存
- **自動プロファイル検出**: 実行中のゲームを検出し適切なプロファイルを適用
- **パラメータの自動チューニング**: OCR結果フィードバックに基づく設定の自動最適化
- **プロファイルのエクスポート/インポート**: 設定の共有と再利用

### 3.2 非機能要件

#### 3.2.1 パフォーマンス要件

- **CPU使用率**: ゲームプレイへの影響を最小限に抑えるため、アイドル時のCPU使用率10%未満
- **メモリ使用量**: 最大100MB以内のメモリ使用量
- **処理時間**: 1フレームあたりの前処理時間50ms以内（20fps相当）
- **スケーラビリティ**: マルチコアCPUでの並列処理によるパフォーマンス向上

#### 3.2.2 拡張性要件

- **新規フィルター追加**: 新しい画像処理フィルターを容易に追加できる設計
- **テキスト検出アルゴリズム**: 検出アルゴリズムの差し替えと拡張が可能
- **プラットフォーム抽象化**: プラットフォームごとの最適化実装を可能にする抽象化
- **サードパーティ連携**: 将来的な外部ライブラリとの連携容易性

#### 3.2.3 堅牢性要件

- **例外処理**: すべての処理ステップでの適切な例外処理と回復メカニズム
- **入力検証**: 不正な入力パラメータに対する検証と適切なエラーメッセージ
- **リソース管理**: 大きな画像リソースの適切な解放とメモリリーク防止
- **エラーログ**: 処理エラーの詳細なロギングとトラブルシューティング情報

#### 3.2.4 テスト容易性要件

- **モック可能性**: インターフェースベースの設計によるテストの容易化
- **フレームワーク分離**: 外部依存性（OpenCV）のモック化と分離
- **パラメータ検証**: 処理パラメータの検証とエッジケースのテスト
- **ベンチマーク**: パフォーマンスと精度の自動テスト

## 4. アーキテクチャ設計

### 4.1 基本アーキテクチャパターン

OCR前処理システムは、クリーンアーキテクチャの原則に従い、以下のレイヤー構造で設計します：

```
+----------------------------------------+
|         Baketa.UI (Avalonia)           |  UIレイヤー
+----------------------------------------+
                    ↑
+----------------------------------------+
|       Baketa.Application               |  アプリケーションレイヤー
+----------------------------------------+
                    ↑
+----------------------------------------+
|    Baketa.Infrastructure.OpenCV        |  インフラストラクチャレイヤー
+----------------------------------------+
                    ↑
+----------------------------------------+
|          Baketa.Core                   |  コアレイヤー
+----------------------------------------+
```

#### 4.1.1 レイヤー構造の定義

1. **コアレイヤー**:
   - インターフェース定義と抽象化
   - ドメインモデルとビジネスルール
   - プラットフォーム非依存の実装

2. **インフラストラクチャレイヤー**:
   - OpenCVラッパーとプラットフォーム固有の実装
   - 画像処理アルゴリズムの具体的実装
   - 外部依存ライブラリとの統合

3. **アプリケーションレイヤー**:
   - ユースケース実装
   - サービスオーケストレーション
   - イベント処理と調整

4. **UIレイヤー**:
   - 設定UI
   - 可視化と診断
   - ユーザーフィードバック

#### 4.1.2 責任分担の明確化

- **コアレイヤー**: 「何をするか」を定義（インターフェース、抽象クラス）
- **インフラストラクチャレイヤー**: 「どのように実現するか」を実装（具体的実装）
- **アプリケーションレイヤー**: 「どのように組み合わせるか」を定義（調整）
- **UIレイヤー**: 「どのように表示/操作するか」を実装（表示）

### 4.2 コンポーネント構成

#### 4.2.1 OpenCVラッパーコンポーネント

```csharp
namespace Baketa.Infrastructure.OpenCV
{
    /// <summary>
    /// OpenCVの機能をラップする基本コンポーネント
    /// </summary>
    public class OpenCvWrapper : IOpenCvWrapper
    {
        // OpenCVのネイティブ機能へのアクセスを提供
    }
}
```

**主な責任**:
- OpenCVライブラリへのアクセス提供
- ネイティブリソースの適切な管理
- プラットフォーム固有の最適化

#### 4.2.2 パイプライン管理コンポーネント

```csharp
namespace Baketa.Core.Services.ImageProcessing
{
    /// <summary>
    /// 画像処理パイプラインを管理するコンポーネント
    /// </summary>
    public interface IImageProcessingPipeline
    {
        /// <summary>
        /// パイプラインにフィルターを追加
        /// </summary>
        void AddFilter(IImageFilter filter);
        
        /// <summary>
        /// パイプラインを実行
        /// </summary>
        Task<IImage> ProcessAsync(IImage inputImage);
        
        /// <summary>
        /// パイプラインの設定を変更
        /// </summary>
        void Configure(ImageProcessingPipelineOptions options);
    }
}
```

**主な責任**:
- 処理ステップの順序管理
- パイプラインの構成と実行
- フィルターの追加と削除
- パイプライン最適化

#### 4.2.3 フィルター群コンポーネント

```csharp
namespace Baketa.Core.Services.ImageProcessing.Filters
{
    /// <summary>
    /// 画像フィルターの基本インターフェース
    /// </summary>
    public interface IImageFilter
    {
        /// <summary>
        /// フィルターの名前
        /// </summary>
        string Name { get; }
        
        /// <summary>
        /// フィルターのパラメータ
        /// </summary>
        IReadOnlyDictionary