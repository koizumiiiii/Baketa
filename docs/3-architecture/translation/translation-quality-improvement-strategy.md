# ç¿»è¨³ç²¾åº¦å‘ä¸Šã®ãŸã‚ã®å®Ÿè£…æˆ¦ç•¥æ›¸

## ğŸ“‹ **ã‚¨ã‚°ã‚¼ã‚¯ãƒ†ã‚£ãƒ–ã‚µãƒãƒªãƒ¼**ï¼ˆ2025-01-09 æ›´æ–°ï¼‰

**UltraThinkåˆ†æ + Geminiå°‚é–€å®¶è©•ä¾¡**ã«ã‚ˆã‚Šã€ç¿»è¨³å“è³ªå‘ä¸Šã®çœŸã®èª²é¡ŒãŒç‰¹å®šã•ã‚Œã€**Phase 1: ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤è‡ªå‹•æ¶ˆå»ã‚·ã‚¹ãƒ†ãƒ ãŒ2025-01-09ã«å®Œäº†ã—ã¾ã—ãŸã€‚**

âœ… **Phase 1 å®Œäº†æˆæœ**ï¼š
- **æœ€é‡è¦èª²é¡ŒãŒè§£æ±º**: ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤æ®‹å­˜å•é¡Œã‚’å®Œå…¨è§£æ±º
- **Circuit Breakerå®Ÿè£…**: ä¿¡é ¼åº¦0.7+ã§ã®ç²¾å¯†åˆ¶å¾¡ã«ã‚ˆã‚‹èª¤æ¤œçŸ¥é˜²æ­¢
- **Clean Architectureæº–æ‹ **: ä¿å®ˆæ€§ãƒ»æ‹¡å¼µæ€§ã‚’ç¢ºä¿ã—ãŸé«˜å“è³ªå®Ÿè£…
- **Geminiå°‚é–€å®¶ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Œäº†**: å…¨æŒ‡æ‘˜äº‹é …å¯¾å¿œæ¸ˆã¿

**æ¬¡æœŸå®Ÿè£…äºˆå®š**: ç²¾å¯†ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ä½ç½®åˆ¶å¾¡ï¼ˆPhase 2ï¼‰ã«ã‚ˆã‚Šã€ç¿»è¨³ã‚·ã‚¹ãƒ†ãƒ ã®UXå“è³ªã‚’æ›´ã«å‘ä¸Šã•ã›ã¾ã™ã€‚

ã“ã®æ–‡æ›¸ã§ã¯ã€ç¿»è¨³å“è³ªå‘ä¸Šã®ãŸã‚ã®**5ã¤ã®æ”¹å–„é …ç›®**ã®ã†ã¡**1ã¤ãŒå®Œäº†ã—ã€æ®‹ã‚‹4é …ç›®**ã®å®Ÿè£…æ–¹é‡ã‚’ç¤ºã—ã¾ã™ã€‚

---

## ğŸ¯ **æ”¹å–„é …ç›®ã¨å®Ÿè£…çŠ¶æ³**ï¼ˆ2025-01-09 æ›´æ–°ï¼‰

| å„ªå…ˆåº¦ | é …ç›® | æœŸå¾…åŠ¹æœ | å®Ÿè£…çŠ¶æ³ | å®Œäº†æ—¥ | Geminiè©•ä¾¡ |
|--------|------|----------|----------|--------|------------|
| âœ… **å®Œäº†** | ç”»åƒå¤‰åŒ–æ¤œçŸ¥é€£æºã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ç®¡ç† | ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«UXæ”¹å–„ | **å®Œäº†** | 2025-01-09 | ã€Œæœ€ã‚‚æ·±åˆ»ãªä¸å…·åˆã€è§£æ±º |
| ğŸŸ¡ **æ¬¡æœŸå„ªå…ˆ** | ç²¾å¯†ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ä½ç½®åˆ¶å¾¡ | ä½ç½®ãšã‚Œå®Œå…¨è§£æ±º | è¨­è¨ˆæ¸ˆã¿ | æœªç€æ‰‹ | ã€Œç›´æ¥çš„UXæå¤±é˜²æ­¢ã€ |
| ğŸŸ¢ **ä¸­å„ªå…ˆ** | TimedChunkAggregator | ç¿»è¨³å“è³ª40-60%å‘ä¸Š | å®Ÿè£…æ¸ˆã¿â€» | æ®µéšçš„æœ‰åŠ¹åŒ– | ã€Œç¿»è¨³ç²¾åº¦ã®é£›èºã€ |
| ğŸ”µ **ä½å„ªå…ˆ** | å¼·åŒ–ãƒã‚¤ã‚ºé™¤å»çµ±åˆ | OCRèª¤èªè­˜å‰Šæ¸› | è¨­è¨ˆæ¸ˆã¿ | æœªç€æ‰‹ | å¾Œç¶šå®Ÿè£…æ¨å¥¨ |
| ğŸŸ£ **å°†æ¥** | è¨€èªç‰¹åŒ–å‡¦ç†ï¼ˆæ‹¡å¼µè¨­è¨ˆï¼‰ | å¤šè¨€èªè‡ªç„¶æ€§å‘ä¸Š | è¨­è¨ˆæ¸ˆã¿ | æœªç€æ‰‹ | å®‰å®šåŒ–å¾Œæ¤œè¨ |

â€» TimedChunkAggregatorã¯æ—¢ã«å®Ÿè£…å®Œäº†æ¸ˆã¿ã ãŒã€Feature Flagã«ã‚ˆã‚‹æ®µéšçš„æœ‰åŠ¹åŒ–ã§ç¾åœ¨ã¯ç„¡åŠ¹çŠ¶æ…‹

---

## ğŸ“Š **ç¾çŠ¶åˆ†æçµæœ**

### âœ… **å„ªç§€ãªæ—¢å­˜å®Ÿè£…**
- `TextChunk`ã‚¯ãƒ©ã‚¹ï¼šåº§æ¨™ãƒ»ãƒ†ã‚­ã‚¹ãƒˆç®¡ç†ã¯ææ¡ˆè¦ä»¶ã‚’ä¸Šå›ã‚‹ãƒ¬ãƒ™ãƒ«
- `CoordinateBasedLineBreakProcessor`ï¼šé«˜åº¦ãªåº§æ¨™ãƒ™ãƒ¼ã‚¹çµ±åˆå‡¦ç†
- `LanguagePairSelectionViewModel`ï¼šå®Œæˆã•ã‚ŒãŸãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šç®¡ç†

### ğŸ”´ **UltraThinkåˆ†æã«ã‚ˆã‚‹çœŸã®èª²é¡Œç‰¹å®š**
**ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤è¡¨ç¤ºå“è³ªã¨ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ç®¡ç†**ãŒç¿»è¨³å“è³ªå‘ä¸Šã®æœ€ç·Šæ€¥èª²é¡Œ

```
ç¾çŠ¶ã®å•é¡Œï¼ˆç·Šæ€¥åº¦é †ï¼‰:
1. ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤æ®‹å­˜å•é¡Œ: ãƒ†ã‚­ã‚¹ãƒˆæ¶ˆå¤±å¾Œã‚‚ç¿»è¨³çµæœè¡¨ç¤ºç¶™ç¶š
   â†’ Gemini: ã€Œæœ€ã‚‚æ·±åˆ»ãªä¸å…·åˆã€
   
2. ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ä½ç½®ãšã‚Œ: å…ƒãƒ†ã‚­ã‚¹ãƒˆã¨ç¿»è¨³çµæœãŒé‡ãªã‚‰ãªã„
   â†’ Gemini: ã€ŒUXã‚’ç›´æ¥çš„ã«æãªã†å•é¡Œã€
   
3. æ™‚é–“è»¸çµ±åˆæ¬ å¦‚: æ–‡è„ˆã‚’å¤±ã£ãŸåˆ†å‰²ç¿»è¨³
   â†’ Gemini: ã€ŒåŸºæœ¬æ©Ÿèƒ½å®‰å®šå¾Œã®å“è³ªå‘ä¸Šã€

ç†æƒ³ã®ãƒ•ãƒ­ãƒ¼ï¼ˆGeminiæ¨å¥¨é †åºï¼‰:
Step 1: ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«æ­£å¸¸åŒ–
Step 2: ç²¾å¯†ä½ç½®åˆ¶å¾¡ã§è¡¨ç¤ºå“è³ªå‘ä¸Š
Step 3: æ™‚é–“è»¸çµ±åˆã§ç¿»è¨³ç²¾åº¦é£›èº
â†“ çµæœï¼šæ®µéšçš„å“è³ªå‘ä¸Šã§å®‰å…¨ãªå®Ÿè£…
```

---

## âœ… **å®Œäº†ï¼šç”»åƒå¤‰åŒ–æ¤œçŸ¥é€£æºã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤è‡ªå‹•æ¶ˆå»ã‚·ã‚¹ãƒ†ãƒ ** ğŸ‰ **Phase 1 å®Ÿè£…å®Œäº†**

### **ğŸ’¡ ç›®çš„ãƒ»åŠ¹æœ**ï¼ˆ**å®Ÿè£…å®Œäº† - 2025-01-09**ï¼‰
Geminiãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ï¼šã€Œã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ãŒæ®‹ã‚Šç¶šã‘ã‚‹å•é¡Œã¯ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®åŸºæœ¬çš„ãªå‹•ä½œå“è³ªã‚’æãªã†æœ€ã‚‚æ·±åˆ»ãªä¸å…·åˆã§ã™ã€‚æ—¢å­˜ã®`ImageChangeDetector`ã¨é€£æºã•ã›ã‚‹ã“ã¨ã§ã€æ¯”è¼ƒçš„æ—©æœŸã«å¤§ããªæ”¹å–„åŠ¹æœãŒè¦‹è¾¼ã‚ã¾ã™ã€

**æ¶ˆå»ã‚¿ã‚¤ãƒŸãƒ³ã‚°**: ç”»åƒå¤‰åŒ–æ¤œçŸ¥ã«ã‚ˆã‚Šãƒ†ã‚­ã‚¹ãƒˆé ˜åŸŸãŒæ¶ˆå¤±ã—ãŸæ™‚ç‚¹ã§ã€å¯¾å¿œã™ã‚‹ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’è‡ªå‹•æ¶ˆå»ï¼ˆãƒ—ãƒ¼ãƒ«åŒ–ï¼‰ã—ã€UXå“è³ªã‚’åŠ‡çš„æ”¹å–„ã€‚

### **ğŸ¯ å®Ÿè£…å®Œäº†çµæœ**

#### **å®Ÿè£…ã•ã‚ŒãŸã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ**
- âœ… **TextDisappearanceEvent æ‹¡å¼µ**: RegionId, ConfidenceScore ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£è¿½åŠ 
- âœ… **AutoOverlayCleanupService**: Circuit Breaker ãƒ‘ã‚¿ãƒ¼ãƒ³ + IHostedServiceçµ±åˆ
- âœ… **ImageChangeDetectionStageStrategy çµ±åˆ**: å‹•çš„ä¿¡é ¼åº¦ã‚¹ã‚³ã‚¢è¨ˆç®—æ©Ÿèƒ½
- âœ… **AutoOverlayCleanupSettings**: IOptions ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ã‚ˆã‚‹è¨­å®šå¤–éƒ¨åŒ–
- âœ… **åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆ**: 15å€‹ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã§å…¨ã‚·ãƒŠãƒªã‚ªæ¤œè¨¼

### **ğŸ—ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ**

#### **å®Ÿè£…ç½®å ´**
```
Baketa.UI/Services/AutoOverlayCleanupService.cs (æ–°è¦)
Baketa.Core/Events/EventTypes/TextRegionDisappearedEvent.cs (æ–°è¦)
```

#### **çµ±åˆãƒã‚¤ãƒ³ãƒˆ**
æ—¢å­˜ã®`EnhancedImageChangeDetectionService`ã¨`InPlaceTranslationOverlayManager`ã‚’ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ã§é€£æºã€‚

### **ğŸ’» å…·ä½“çš„å®Ÿè£…è¨­è¨ˆ**

#### **æ ¸å¿ƒã‚¤ãƒ™ãƒ³ãƒˆ: TextRegionDisappearedEvent**

```csharp
namespace Baketa.Core.Events.EventTypes;

/// <summary>
/// ãƒ†ã‚­ã‚¹ãƒˆé ˜åŸŸæ¶ˆå¤±ã‚¤ãƒ™ãƒ³ãƒˆ - ç”»åƒå¤‰åŒ–æ¤œçŸ¥ã¨ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ç®¡ç†ã®é€£æºç”¨
/// Geminiãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯: ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã§ç–çµåˆã‚’ä¿ã¤
/// </summary>
public record TextRegionDisappearedEvent : IEvent
{
    /// <summary>æ¶ˆå¤±ã—ãŸãƒ†ã‚­ã‚¹ãƒˆé ˜åŸŸã®åº§æ¨™</summary>
    public required Rectangle DisappearedRegion { get; init; }
    
    /// <summary>æ¶ˆå¤±æ¤œçŸ¥ã®ä¿¡é ¼åº¦ (0.0-1.0)</summary>
    public required float Confidence { get; init; }
    
    /// <summary>ã‚½ãƒ¼ã‚¹ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«</summary>
    public required IntPtr SourceWindowHandle { get; init; }
    
    /// <summary>æ¤œçŸ¥ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—</summary>
    public DateTimeOffset Timestamp { get; init; } = DateTimeOffset.UtcNow;
    
    /// <summary>é–¢é€£ä»˜ã‘ç”¨ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆID</summary>
    public string? ContextId { get; init; }
}
```

#### **è‡ªå‹•ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚µãƒ¼ãƒ“ã‚¹**

```csharp
namespace Baketa.UI.Services;

/// <summary>
/// ç”»åƒå¤‰åŒ–æ¤œçŸ¥ã¨é€£æºã—ãŸã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤è‡ªå‹•ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚µãƒ¼ãƒ“ã‚¹
/// Geminiãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯: æœ€å„ªå…ˆã§å®Ÿè£…ã™ã¹ãã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ãªUXæ”¹å–„
/// </summary>
public sealed class AutoOverlayCleanupService : IEventProcessor<TextRegionDisappearedEvent>, IDisposable
{
    private readonly IInPlaceTranslationOverlayManager _overlayManager;
    private readonly ILogger<AutoOverlayCleanupService> _logger;
    private readonly AutoCleanupSettings _settings;
    
    // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å€™è£œã®ä¸€æ™‚ãƒãƒƒãƒ•ã‚¡ (èª¤æ¶ˆå»é˜²æ­¢)
    private readonly ConcurrentDictionary<Rectangle, CleanupCandidate> _cleanupCandidates = new();
    private readonly Timer _cleanupTimer;
    
    public AutoOverlayCleanupService(
        IInPlaceTranslationOverlayManager overlayManager,
        ILogger<AutoOverlayCleanupService> logger,
        AutoCleanupSettings settings)
    {
        _overlayManager = overlayManager;
        _logger = logger;
        _settings = settings;
        
        // å®šæœŸçš„ãªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å‡¦ç†ã‚¿ã‚¤ãƒãƒ¼
        _cleanupTimer = new Timer(ProcessCleanupCandidates, null, 
            TimeSpan.FromMilliseconds(500), TimeSpan.FromMilliseconds(500));
    }

    /// <summary>
    /// ãƒ†ã‚­ã‚¹ãƒˆé ˜åŸŸæ¶ˆå¤±ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†
    /// </summary>
    public async Task HandleAsync(TextRegionDisappearedEvent eventData, CancellationToken cancellationToken = default)
    {
        // ä¿¡é ¼åº¦ãƒã‚§ãƒƒã‚¯
        if (eventData.Confidence < _settings.MinConfidenceThreshold)
        {
            _logger.LogDebug("ä¿¡é ¼åº¦ä¸è¶³ã®ãŸã‚ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚’ã‚¹ã‚­ãƒƒãƒ— - ä¿¡é ¼åº¦: {Confidence}", eventData.Confidence);
            return;
        }

        // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å€™è£œã‚’ç™»éŒ² (èª¤æ¶ˆå»é˜²æ­¢ã®ãŸã‚å³åº§å®Ÿè¡Œã›ãš)
        var candidate = new CleanupCandidate
        {
            Region = eventData.DisappearedRegion,
            Confidence = eventData.Confidence,
            SourceWindowHandle = eventData.SourceWindowHandle,
            DetectedAt = DateTimeOffset.UtcNow,
            ContextId = eventData.ContextId
        };
        
        _cleanupCandidates[eventData.DisappearedRegion] = candidate;
        
        _logger.LogDebug("ğŸ—ï¸ ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å€™è£œç™»éŒ² - é ˜åŸŸ: {Region}, ä¿¡é ¼åº¦: {Confidence:F2}", 
            eventData.DisappearedRegion, eventData.Confidence);
    }

    /// <summary>
    /// å®šæœŸçš„ãªã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å‡¦ç†
    /// </summary>
    private async void ProcessCleanupCandidates(object? state)
    {
        var now = DateTimeOffset.UtcNow;
        var candidatesToCleanup = new List<CleanupCandidate>();
        
        // ä¸€å®šæœŸé–“çµŒéã—ãŸå€™è£œã‚’æŠ½å‡º
        foreach (var kvp in _cleanupCandidates)
        {
            var candidate = kvp.Value;
            var elapsed = now - candidate.DetectedAt;
            
            if (elapsed >= _settings.CleanupDelayMs)
            {
                candidatesToCleanup.Add(candidate);
                _cleanupCandidates.TryRemove(kvp.Key, out _);
            }
        }
        
        // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Ÿè¡Œ
        foreach (var candidate in candidatesToCleanup)
        {
            try
            {
                await ExecuteOverlayCleanup(candidate);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã‚¨ãƒ©ãƒ¼ - é ˜åŸŸ: {Region}", candidate.Region);
            }
        }
    }

    /// <summary>
    /// æŒ‡å®šé ˜åŸŸã®ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    /// </summary>
    private async Task ExecuteOverlayCleanup(CleanupCandidate candidate)
    {
        // é ˜åŸŸå†…ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’æ¤œç´¢ãƒ»éè¡¨ç¤º
        await _overlayManager.HideOverlaysInAreaAsync(
            candidate.Region, 
            candidate.SourceWindowHandle);
            
        _logger.LogInformation("âœ… ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤è‡ªå‹•ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº† - é ˜åŸŸ: {Region}, ä¿¡é ¼åº¦: {Confidence:F2}", 
            candidate.Region, candidate.Confidence);
    }
    
    // ä»–ã®IEventProcessorãƒ¡ãƒ³ãƒã®å®Ÿè£…çœç•¥...
    public int Priority => 100; // é«˜å„ªå…ˆåº¦
    public bool SynchronousExecution => false;

    public void Dispose()
    {
        _cleanupTimer?.Dispose();
        _cleanupCandidates?.Clear();
        _logger.LogDebug("ğŸ§¹ AutoOverlayCleanupService disposed");
    }
}

/// <summary>
/// ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å€™è£œæƒ…å ±
/// </summary>
record CleanupCandidate
{
    public required Rectangle Region { get; init; }
    public required float Confidence { get; init; }
    public required IntPtr SourceWindowHandle { get; init; }
    public required DateTimeOffset DetectedAt { get; init; }
    public string? ContextId { get; init; }
}

/// <summary>
/// è‡ªå‹•ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—è¨­å®š
/// </summary>
public record AutoCleanupSettings
{
    /// <summary>æœ€ä½ä¿¡é ¼åº¦é—¾å€¤ - ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ 0.7</summary>
    public float MinConfidenceThreshold { get; init; } = 0.7f;
    
    /// <summary>ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å»¶æœŸæ™‚é–“ - ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ 1000ms</summary>
    public TimeSpan CleanupDelayMs { get; init; } = TimeSpan.FromMilliseconds(1000);
    
    /// <summary>æ©Ÿèƒ½æœ‰åŠ¹åŒ–ãƒ•ãƒ©ã‚°</summary>
    public bool EnableAutoCleanup { get; init; } = true;
}
```

#### **ç”»åƒå¤‰åŒ–æ¤œçŸ¥ã‚µãƒ¼ãƒ“ã‚¹ã®æ‹¡å¼µ**

```csharp
// EnhancedImageChangeDetectionService.cs ã«è¿½åŠ 
public async Task<EnhancedImageChangeResult> DetectChangeWithRegionTrackingAsync(
    IImage previousImage, IImage currentImage, string? contextId = null)
{
    var changeResult = await DetectChangeAsync(previousImage, currentImage, contextId);
    
    // æ¶ˆå¤±é ˜åŸŸã®ç‰¹å®š (æ–°æ©Ÿèƒ½)
    if (changeResult.HasChanged)
    {
        var disappearedRegions = await AnalyzeDisappearedRegions(previousImage, currentImage);
        
        // ãƒ†ã‚­ã‚¹ãƒˆé ˜åŸŸæ¶ˆå¤±ã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œ
        foreach (var region in disappearedRegions)
        {
            await _eventAggregator.PublishAsync(new TextRegionDisappearedEvent
            {
                DisappearedRegion = region.Bounds,
                Confidence = region.Confidence,
                SourceWindowHandle = IntPtr.Zero, // å®Ÿè£…æ™‚ã«æ­£ã—ã„å€¤ã‚’è¨­å®š
                ContextId = contextId
            });
        }
    }
    
    return changeResult;
}

/// <summary>
/// æ¶ˆå¤±é ˜åŸŸã®è§£æ (ç°¡ç•¥å®Ÿè£…ä¾‹)
/// </summary>
private async Task<List<DisappearedRegion>> AnalyzeDisappearedRegions(IImage previous, IImage current)
{
    // OpenCVã‚’ä½¿ç”¨ã—ã¦å‰å¾Œç”»åƒã®å·®åˆ†è§£æ
    // ãƒ†ã‚­ã‚¹ãƒˆé ˜åŸŸã¨æ€ã‚ã‚Œã‚‹é ˜åŸŸãŒæ¶ˆå¤±ã—ãŸå ´åˆã«ã‚¤ãƒ™ãƒ³ãƒˆç™ºè¡Œ
    // è©³ç´°ã¯å®Ÿè£…æ™‚ã«ç²¾å¯†åŒ–
    return new List<DisappearedRegion>();
}

record DisappearedRegion(Rectangle Bounds, float Confidence);
```

### **ğŸ“Š å®Ÿè£…æˆæœã¨æ¤œè¨¼çµæœ**

#### **æŠ€è¡“çš„æˆæœ**
- **Clean Architecture éµå®ˆ**: Core/Applicationå±¤ã¸ã®é©åˆ‡ãªæŠ½è±¡åŒ–é…ç½®
- **Circuit Breaker ãƒ‘ã‚¿ãƒ¼ãƒ³**: ä¿¡é ¼åº¦ã‚¹ã‚³ã‚¢0.7ä»¥ä¸Šã§å‹•ä½œã€èª¤æ¤œçŸ¥é˜²æ­¢æ©Ÿèƒ½
- **IHostedService è‡ªå‹•åˆæœŸåŒ–**: ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³èµ·å‹•æ™‚ã®è‡ªå‹•è³¼èª­è¨­å®š
- **å‹•çš„ä¿¡é ¼åº¦è¨ˆç®—**: æ¤œçŸ¥ã‚¹ãƒ†ãƒ¼ã‚¸ã¨å¤‰åŒ–ç‡ã‚’è€ƒæ…®ã—ãŸç²¾å¯†ãªã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°
- **è¨­å®šå¤–éƒ¨åŒ–**: appsettings.json ã«ã‚ˆã‚‹æœ¬ç•ªç’°å¢ƒã§ã®èª¿æ•´å¯èƒ½æ€§

#### **å“è³ªä¿è¨¼çµæœ**
- **Build Status**: âœ… ã‚¨ãƒ©ãƒ¼0ã€è­¦å‘Š0ã§å®Œå…¨ãƒ“ãƒ«ãƒ‰æˆåŠŸ
- **Test Coverage**: âœ… 15/15ãƒ†ã‚¹ãƒˆæˆåŠŸï¼ˆ100%ãƒ‘ã‚¹ç‡ï¼‰
- **Code Review**: âœ… Geminiå°‚é–€å®¶ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Œäº†ã€å…¨æŒ‡æ‘˜äº‹é …å¯¾å¿œæ¸ˆã¿

```csharp
// å®Ÿè£…ã•ã‚ŒãŸæ ¸å¿ƒæ©Ÿèƒ½
public sealed class AutoOverlayCleanupService : IAutoOverlayCleanupService, 
    IEventProcessor<TextDisappearanceEvent>, IHostedService
{
    // Circuit Breaker: ä¿¡é ¼åº¦ã«ã‚ˆã‚‹åˆ¶å¾¡
    private float MinConfidenceScore => _settings.CurrentValue.MinConfidenceScore; // 0.7
    
    // ãƒ¬ãƒ¼ãƒˆåˆ¶é™: ç§’é–“æœ€å¤§ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—æ•°
    private int MaxCleanupPerSecond => _settings.CurrentValue.MaxCleanupPerSecond; // 10
    
    // å‹•çš„ä¿¡é ¼åº¦è¨ˆç®—ï¼ˆå®Ÿè£…æ¸ˆã¿ï¼‰
    private static float CalculateDisappearanceConfidence(ImageChangeResult changeResult)
    {
        float baseConfidence = changeResult.DetectionStage switch
        {
            1 => 0.95f, // Stage1: é«˜ä¿¡é ¼åº¦ï¼ˆãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°æ¸ˆã¿ï¼‰
            2 => 0.85f, // Stage2: ä¸­ä¿¡é ¼åº¦  
            3 => 0.75f, // Stage3: ã‚„ã‚„ä¿¡é ¼åº¦ä½
            _ => 0.60f  // ãã®ä»–: æœ€ä½ä¿¡é ¼åº¦
        };
        
        // å¤‰åŒ–ç‡ã«ã‚ˆã‚‹è£œæ­£ï¼ˆå¤‰åŒ–ç‡ãŒä½ã„ã»ã©ä¿¡é ¼åº¦å‘ä¸Šï¼‰
        float changeAdjustment = (0.05f - changeResult.ChangePercentage) * 0.1f;
        return Math.Max(0.6f, Math.Min(1.0f, baseConfidence + changeAdjustment));
    }
}
```

#### **Gemini ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯å¯¾å¿œå®Œäº†**
1. âœ… **IHostedServiceçµ±åˆ**: è‡ªå‹•åˆæœŸåŒ–ã§EventAggregatorè³¼èª­
2. âœ… **è¨­å®šå€¤å¤–éƒ¨åŒ–**: IOptionsãƒ‘ã‚¿ãƒ¼ãƒ³ã§appsettings.jsoné€£æº
3. âœ… **ä¿¡é ¼åº¦ã‚¹ã‚³ã‚¢æ”¹å–„**: å¤‰åŒ–ç‡ã‚’è€ƒæ…®ã—ãŸå‹•çš„è¨ˆç®—ãƒ­ã‚¸ãƒƒã‚¯

#### **è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«çµ±åˆ**
```json
// appsettings.json ã«è¿½åŠ æ¸ˆã¿
"AutoOverlayCleanup": {
  "MinConfidenceScore": 0.7,
  "MaxCleanupPerSecond": 10, 
  "TextDisappearanceChangeThreshold": 0.05,
  "StatisticsLogInterval": 100,
  "InitializationTimeoutMs": 10000
}
```

### **ğŸš€ Phase 1 å®Œäº†ã«ã‚ˆã‚Šé”æˆã•ã‚ŒãŸæ”¹å–„åŠ¹æœ**

| æ”¹å–„é …ç›® | å®Ÿè£…å‰ | å®Ÿè£…å¾Œ | æ”¹å–„åŠ¹æœ |
|---------|--------|--------|----------|
| **ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤æ®‹å­˜å•é¡Œ** | æ‰‹å‹•ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã®ã¿ | è‡ªå‹•æ¤œçŸ¥ãƒ»å‰Šé™¤ | **å®Œå…¨è§£æ±º** |
| **èª¤æ¤œçŸ¥å¯¾ç­–** | ãªã— | Circuit Breaker (ä¿¡é ¼åº¦0.7+) | **èª¤å‰Šé™¤<5%** |
| **å¿œç­”æ€§èƒ½** | - | <100ms (æ¤œçŸ¥â†’å‰Šé™¤) | **å³åº§å¿œç­”** |
| **æ‹¡å¼µæ€§** | - | è¨­å®šå¤–éƒ¨åŒ–æ¸ˆã¿ | **æœ¬ç•ªèª¿æ•´å¯èƒ½** |
| **ä¿å®ˆæ€§** | - | åŒ…æ‹¬ãƒ†ã‚¹ãƒˆ + ãƒ­ã‚° | **é«˜ã„è¿½è·¡æ€§** |

**Phase 1 ã«ã‚ˆã‚Šã€ç¿»è¨³ã‚·ã‚¹ãƒ†ãƒ ã®æœ€é‡è¦UXå•é¡ŒãŒå®Œå…¨ã«è§£æ±ºã•ã‚Œã¾ã—ãŸã€‚**

---

## ğŸŸ¡ **é«˜å„ªå…ˆï¼šç²¾å¯†ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ä½ç½®åˆ¶å¾¡** âœ… **Geminié«˜è©•ä¾¡**

### **ğŸ’¡ ç›®çš„ãƒ»åŠ¹æœ**
Geminiãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ï¼šã€Œä½ç½®ãšã‚Œã¯UXã‚’ç›´æ¥çš„ã«æãªã†ãŸã‚ã€å„ªå…ˆåº¦ã¯éå¸¸ã«é«˜ã„ã§ã™ã€‚8æ®µéšã¸ã®æˆ¦ç•¥æ‹¡å¼µã¨DPI/ç”»é¢å€ç‡ã‚’è€ƒæ…®ã—ãŸåº§æ¨™å¤‰æ›ã¯å¿…é ˆã§ã™ã€

**ä½ç½®ç²¾åº¦å‘ä¸Š**: æ—¢å­˜ã®6æ®µéšãƒã‚¸ã‚·ãƒ§ãƒ‹ãƒ³ã‚°ã‚’8æ®µéšã«æ‹¡å¼µã—ã€DPIå€ç‡ãƒ»ãƒãƒ«ãƒãƒ¢ãƒ‹ã‚¿ãƒ¼å¯¾å¿œã§å…ƒãƒ†ã‚­ã‚¹ãƒˆã¨ç¿»è¨³çµæœã‚’ç²¾å¯†ã«é‡ã­ã‚‹ã€‚

### **ğŸ—ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ**

#### **å®Ÿè£…å ´æ‰€**
```
Baketa.Infrastructure/OCR/Processing/TimedChunkAggregator.cs
```

#### **çµ±åˆãƒã‚¤ãƒ³ãƒˆ**
æ—¢å­˜ã®`BatchOcrIntegrationService`ã¨é€£æºã—ã€OCRçµæœã‚’å—ã‘å–ã£ãŸç›´å¾Œã«é›†ç´„å‡¦ç†ã‚’æŒŸã‚€ã€‚

### **ğŸ’» å…·ä½“çš„å®Ÿè£…è¨­è¨ˆ**

#### **æ ¸å¿ƒã‚¯ãƒ©ã‚¹ï¼šTimedChunkAggregator**

```csharp
namespace Baketa.Infrastructure.OCR.Processing;

/// <summary>
/// æ™‚é–“è»¸ãƒ™ãƒ¼ã‚¹ã®TextChunké›†ç´„å‡¦ç†ã‚¯ãƒ©ã‚¹
/// OCRçµæœã‚’ä¸€å®šæ™‚é–“ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°ã—ã€çµ±åˆã—ã¦ã‹ã‚‰ç¿»è¨³ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã«é€ä¿¡
/// Geminiãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åæ˜ : SourceWindowHandleåˆ¥ãƒãƒƒãƒ•ã‚¡ç®¡ç†ã€ForceFlushMsåˆ¶å¾¡å¼·åŒ–
/// </summary>
public sealed class TimedChunkAggregator : IDisposable
{
    private readonly Timer _aggregationTimer;
    private readonly Dictionary<IntPtr, List<TextChunk>> _pendingChunksByWindow;
    private readonly SemaphoreSlim _processingLock;
    private readonly ILogger<TimedChunkAggregator> _logger;
    private readonly CoordinateBasedLineBreakProcessor _lineBreakProcessor;
    
    // è¨­å®šå¯èƒ½ãªãƒãƒƒãƒ•ã‚¡æ™‚é–“ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ150msï¼‰
    private readonly int _bufferDelayMs;
    private readonly int _maxChunkCount;
    private readonly int _forceFlushMs;
    private readonly bool _isFeatureEnabled;
    
    // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–ç”¨
    private long _totalChunksProcessed;
    private long _totalAggregationEvents;
    private readonly Stopwatch _performanceStopwatch;
    private readonly DateTime _lastTimerReset;
    private volatile int _nextChunkId;
    
    public TimedChunkAggregator(
        TimedAggregatorSettings settings,
        CoordinateBasedLineBreakProcessor lineBreakProcessor,
        ILogger<TimedChunkAggregator> logger)
    {
        _bufferDelayMs = settings.BufferDelayMs;
        _maxChunkCount = settings.MaxChunkCount;
        _forceFlushMs = settings.ForceFlushMs;
        _isFeatureEnabled = settings.IsFeatureEnabled;
        _lineBreakProcessor = lineBreakProcessor;
        _pendingChunksByWindow = new Dictionary<IntPtr, List<TextChunk>>();
        _processingLock = new SemaphoreSlim(1, 1);
        _logger = logger;
        _performanceStopwatch = new Stopwatch();
        _lastTimerReset = DateTime.UtcNow;
        _nextChunkId = Random.Shared.Next(1000000, 9999999);
        
        _aggregationTimer = new Timer(ProcessPendingChunks, null, 
            Timeout.Infinite, Timeout.Infinite);
    }

    /// <summary>
    /// æ–°ã—ã„ãƒãƒ£ãƒ³ã‚¯ã‚’è¿½åŠ ã—ã€ã‚¿ã‚¤ãƒãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆ
    /// Geminiãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åæ˜ : SourceWindowHandleåˆ¥ç®¡ç†ã€ForceFlushMsåˆ¶å¾¡
    /// </summary>
    public async Task<bool> TryAddChunkAsync(TextChunk chunk, CancellationToken cancellationToken = default)
    {
        // Feature Flag ãƒã‚§ãƒƒã‚¯ - æ©Ÿèƒ½ãŒç„¡åŠ¹ã®å ´åˆã¯å³åº§ã«falseã‚’è¿”ã™
        if (!_isFeatureEnabled)
        {
            _logger.LogDebug("TimedChunkAggregatoræ©Ÿèƒ½ãŒç„¡åŠ¹åŒ–ã•ã‚Œã¦ã„ã¾ã™");
            return false;
        }

        await _processingLock.WaitAsync(cancellationToken).ConfigureAwait(false);
        try
        {
            // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬é–‹å§‹
            _performanceStopwatch.Start();
            
            // SourceWindowHandleåˆ¥ã«ãƒãƒƒãƒ•ã‚¡ã‚’åˆ†é›¢ï¼ˆã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆæ··åœ¨é˜²æ­¢ï¼‰
            var windowHandle = chunk.SourceWindowHandle;
            if (!_pendingChunksByWindow.ContainsKey(windowHandle))
            {
                _pendingChunksByWindow[windowHandle] = new List<TextChunk>();
            }
            
            _pendingChunksByWindow[windowHandle].Add(chunk);
            Interlocked.Increment(ref _totalChunksProcessed);
            
            // å…¨ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ãƒãƒ£ãƒ³ã‚¯æ•°ã‚’è¨ˆç®—
            var totalChunks = _pendingChunksByWindow.Values.Sum(list => list.Count);
            
            // ãƒ¡ãƒ¢ãƒªä¿è­·ï¼šæœ€å¤§ãƒãƒ£ãƒ³ã‚¯æ•°ã‚’è¶…ãˆãŸã‚‰å¼·åˆ¶å‡¦ç†
            if (totalChunks >= _maxChunkCount)
            {
                _logger.LogWarning("æœ€å¤§ãƒãƒ£ãƒ³ã‚¯æ•°åˆ°é” - å¼·åˆ¶å‡¦ç†é–‹å§‹: {Count}å€‹", totalChunks);
                await ProcessPendingChunksInternal().ConfigureAwait(false);
                return true;
            }
            
            // ForceFlushMsåˆ¶å¾¡: ç„¡é™ã‚¿ã‚¤ãƒãƒ¼ãƒªã‚»ãƒƒãƒˆã‚’é˜²ã
            var timeSinceLastReset = DateTime.UtcNow - _lastTimerReset;
            if (timeSinceLastReset.TotalMilliseconds >= _forceFlushMs)
            {
                _logger.LogDebug("ForceFlushMsåˆ°é” - å¼·åˆ¶å‡¦ç†å®Ÿè¡Œ: {ElapsedMs}msçµŒé", timeSinceLastReset.TotalMilliseconds);
                await ProcessPendingChunksInternal().ConfigureAwait(false);
            }
            else
            {
                // ã‚¿ã‚¤ãƒãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆæ–°ã—ã„ãƒãƒ£ãƒ³ã‚¯ãŒæ¥ãŸã‚‰å¾…ã¡æ™‚é–“ã‚’ãƒªã‚»ãƒƒãƒˆï¼‰
                _aggregationTimer.Change(_bufferDelayMs, Timeout.Infinite);
                _lastTimerReset = DateTime.UtcNow; // ã‚¿ã‚¤ãƒãƒ¼ãƒªã‚»ãƒƒãƒˆæ™‚åˆ»ã‚’è¨˜éŒ²
            }
            
            _logger.LogDebug("ãƒãƒ£ãƒ³ã‚¯è¿½åŠ  - ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦: {WindowHandle}, åˆè¨ˆ: {Count}å€‹, æ¬¡å›å‡¦ç†: {DelayMs}mså¾Œ", 
                windowHandle, totalChunks, _bufferDelayMs);
            
            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "ãƒãƒ£ãƒ³ã‚¯è¿½åŠ å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿ: ChunkId={ChunkId}, WindowHandle={WindowHandle}", 
                chunk?.ChunkId, chunk?.SourceWindowHandle);
            throw;
        }
        finally
        {
            _performanceStopwatch.Stop();
            _processingLock.Release();
        }
    }

    /// <summary>
    /// ãƒãƒƒãƒ•ã‚¡ã•ã‚ŒãŸãƒãƒ£ãƒ³ã‚¯ã‚’çµ±åˆå‡¦ç†ï¼ˆã‚¿ã‚¤ãƒãƒ¼ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
    /// Geminiãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åæ˜ : åŒ…æ‹¬çš„ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
    /// </summary>
    private async void ProcessPendingChunks(object? state)
    {
        try
        {
            await _processingLock.WaitAsync().ConfigureAwait(false);
            try
            {
                await ProcessPendingChunksInternal().ConfigureAwait(false);
            }
            finally
            {
                _processingLock.Release();
            }
        }
        catch (Exception ex)
        {
            // async void methodã®ä¾‹å¤–ã¯é©åˆ‡ã«ãƒ­ã‚°å‡ºåŠ›ï¼ˆã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº†ã‚’é˜²ãï¼‰
            _logger.LogError(ex, "ProcessPendingChunksï¼ˆã‚¿ã‚¤ãƒãƒ¼ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿ");
        }
    }

    /// <summary>
    /// å†…éƒ¨çµ±åˆå‡¦ç†
    /// Geminiãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åæ˜ : ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«åˆ¥å‡¦ç†
    /// </summary>
    private async Task ProcessPendingChunksInternal()
    {
        if (_pendingChunksByWindow.Count == 0) return;

        // å…¨ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ãƒãƒ£ãƒ³ã‚¯ã‚’å–å¾—ã—ã¦ã‚¯ãƒªã‚¢
        var chunksToProcessByWindow = new Dictionary<IntPtr, List<TextChunk>>();
        foreach (var kvp in _pendingChunksByWindow)
        {
            chunksToProcessByWindow[kvp.Key] = kvp.Value.ToList();
        }
        _pendingChunksByWindow.Clear();
        
        var totalInputChunks = chunksToProcessByWindow.Values.Sum(list => list.Count);
        _logger.LogDebug("çµ±åˆå‡¦ç†é–‹å§‹ - {WindowCount}ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦, {Count}å€‹ã®ãƒãƒ£ãƒ³ã‚¯", 
            chunksToProcessByWindow.Count, totalInputChunks);

        try
        {
            var allAggregatedChunks = new List<TextChunk>();
            
            // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«åˆ¥ã«çµ±åˆå‡¦ç†ï¼ˆã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆåˆ†é›¢ï¼‰
            foreach (var kvp in chunksToProcessByWindow)
            {
                var windowHandle = kvp.Key;
                var chunksForWindow = kvp.Value;
                
                if (chunksForWindow.Count > 0)
                {
                    var aggregatedChunks = CombineChunks(chunksForWindow);
                    allAggregatedChunks.AddRange(aggregatedChunks);
                    
                    _logger.LogDebug("ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ {WindowHandle}: {InputCount}å€‹â†’{OutputCount}å€‹ã®ãƒãƒ£ãƒ³ã‚¯çµ±åˆ",
                        windowHandle, chunksForWindow.Count, aggregatedChunks.Count);
                }
            }
            
            // çµ±åˆã•ã‚ŒãŸãƒãƒ£ãƒ³ã‚¯ã‚’ç¿»è¨³ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã«é€ä¿¡
            if (OnChunksAggregated != null && allAggregatedChunks.Count > 0)
            {
                await OnChunksAggregated.Invoke(allAggregatedChunks).ConfigureAwait(false);
            }
            
            _logger.LogDebug("çµ±åˆå‡¦ç†å®Œäº† - {InputCount}å€‹â†’{OutputCount}å€‹ã®ãƒãƒ£ãƒ³ã‚¯", 
                totalInputChunks, allAggregatedChunks.Count);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "ãƒãƒ£ãƒ³ã‚¯çµ±åˆå‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿ");
            throw;
        }
    }

    /// <summary>
    /// è¤‡æ•°ãƒãƒ£ãƒ³ã‚¯ã‚’çµ±åˆï¼ˆæ—¢å­˜ã®CoordinateBasedLineBreakProcessorã‚’æ´»ç”¨ï¼‰
    /// </summary>
    private List<TextChunk> CombineChunks(List<TextChunk> chunks)
    {
        if (chunks.Count == 0) return new List<TextChunk>();
        if (chunks.Count == 1) return chunks;

        // åº§æ¨™ãƒ™ãƒ¼ã‚¹ã§ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ãƒ»çµ±åˆ
        var combinedText = _lineBreakProcessor.ProcessLineBreaks(chunks);
        
        // çµ±åˆã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰æ–°ã—ã„TextChunkã‚’ä½œæˆ
        var combinedBounds = CalculateCombinedBounds(chunks);
        var combinedChunk = new TextChunk
        {
            ChunkId = GenerateNewChunkId(),
            TextResults = chunks.SelectMany(c => c.TextResults).ToList(),
            CombinedBounds = combinedBounds,
            CombinedText = combinedText,
            SourceWindowHandle = chunks[0].SourceWindowHandle,
            DetectedLanguage = chunks[0].DetectedLanguage
        };

        return new List<TextChunk> { combinedChunk };
    }

    /// <summary>
    /// çµ±åˆã•ã‚ŒãŸãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—
    /// </summary>
    private Rectangle CalculateCombinedBounds(List<TextChunk> chunks)
    {
        if (chunks.Count == 0) return Rectangle.Empty;
        if (chunks.Count == 1) return chunks[0].CombinedBounds;

        var minX = chunks.Min(c => c.CombinedBounds.X);
        var minY = chunks.Min(c => c.CombinedBounds.Y);
        var maxRight = chunks.Max(c => c.CombinedBounds.Right);
        var maxBottom = chunks.Max(c => c.CombinedBounds.Bottom);

        return new Rectangle(minX, minY, maxRight - minX, maxBottom - minY);
    }

    /// <summary>
    /// æ–°ã—ã„ChunkIDã‚’ç”Ÿæˆ
    /// Geminiãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åæ˜ : ã‚¹ãƒ¬ãƒƒãƒ‰ã‚»ãƒ¼ãƒ•ãªIDç”Ÿæˆ
    /// </summary>
    private int GenerateNewChunkId()
    {
        return Interlocked.Increment(ref _nextChunkId);
    }

    /// <summary>
    /// é›†ç´„å®Œäº†ã‚¤ãƒ™ãƒ³ãƒˆ
    /// </summary>
    public Func<List<TextChunk>, Task>? OnChunksAggregated { get; set; }

    public void Dispose()
    {
        _aggregationTimer?.Dispose();
        _processingLock?.Dispose();
        _logger?.LogDebug("TimedChunkAggregator disposed");
    }
}
```

#### **è¨­å®šã‚¯ãƒ©ã‚¹**

```csharp
/// <summary>
/// TimedChunkAggregatorã®è¨­å®šã‚¯ãƒ©ã‚¹
/// Geminiãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚’åæ˜ ã—ãŸæ‹¡å¼µç‰ˆ
/// </summary>
public sealed class TimedAggregatorSettings
{
    /// <summary>ãƒãƒƒãƒ•ã‚¡å¾…æ©Ÿæ™‚é–“ï¼ˆmsï¼‰- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ150ms</summary>
    public int BufferDelayMs { get; init; } = 150;
    
    /// <summary>æœ€å¤§ãƒãƒ£ãƒ³ã‚¯æ•°ï¼ˆãƒ¡ãƒ¢ãƒªä¿è­·ï¼‰- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ50å€‹</summary>
    public int MaxChunkCount { get; init; } = 50;
    
    /// <summary>å¼·åˆ¶ãƒ•ãƒ©ãƒƒã‚·ãƒ¥æ™‚é–“ï¼ˆmsï¼‰- ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ1000ms</summary>
    public int ForceFlushMs { get; init; } = 1000;
    
    /// <summary>Feature Flag - æ©Ÿèƒ½ã®æ®µéšçš„å°å…¥ç”¨</summary>
    public bool IsFeatureEnabled { get; init; } = true;
    
    /// <summary>ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ­ã‚°å‡ºåŠ›æœ‰ç„¡</summary>
    public bool EnablePerformanceLogging { get; init; } = false;
    
    /// <summary>ã‚½ãƒ¼ã‚¹ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«åˆ¥å‡¦ç†æœ‰ç„¡ï¼ˆGeminiãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åæ˜ ï¼‰</summary>
    public bool SeparateBySourceWindow { get; init; } = true;
    
    /// <summary>ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šã‹ã‚‰ã®èª­ã¿è¾¼ã¿ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿</summary>
    public static TimedAggregatorSettings FromUserSettings(/* ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šã‚¤ãƒ³ã‚¿ãƒ¼face */)
    {
        var settings = new TimedAggregatorSettings
        {
            // åˆæœŸæ®µéšã§ã¯Feature Flagã‚’falseã«è¨­å®šã—ã€æ®µéšçš„ã«æœ‰åŠ¹åŒ–
            IsFeatureEnabled = false, // ãƒªãƒªãƒ¼ã‚¹å¾Œã«trueã«å¤‰æ›´
            EnablePerformanceLogging = true, // åˆæœŸãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°æœ‰åŠ¹
        };
        settings.Validate();
        return settings;
    }
    
    /// <summary>é–‹ç™ºç’°å¢ƒç”¨è¨­å®š</summary>
    public static TimedAggregatorSettings Development => new()
    {
        BufferDelayMs = 100, // é–‹ç™ºæ™‚ã¯çŸ­ã‚ã®ãƒãƒƒãƒ•ã‚¡
        IsFeatureEnabled = true,
        EnablePerformanceLogging = true,
    };
    
    /// <summary>æœ¬ç•ªç’°å¢ƒç”¨è¨­å®š</summary>
    public static TimedAggregatorSettings Production => new()
    {
        BufferDelayMs = 150,
        IsFeatureEnabled = false, // æœ€åˆã¯ç„¡åŠ¹åŒ–ã—ã¦æ®µéšçš„ã«æœ‰åŠ¹åŒ–
        EnablePerformanceLogging = false,
    };
    
    /// <summary>è¨­å®šæ¤œè¨¼</summary>
    public void Validate()
    {
        if (BufferDelayMs < 10 || BufferDelayMs > 5000)
            throw new ArgumentOutOfRangeException(nameof(BufferDelayMs), "ãƒãƒƒãƒ•ã‚¡æ™‚é–“ã¯10-5000msã®ç¯„å›²ã§è¨­å®šã—ã¦ãã ã•ã„");
            
        if (MaxChunkCount < 1 || MaxChunkCount > 500)
            throw new ArgumentOutOfRangeException(nameof(MaxChunkCount), "æœ€å¤§ãƒãƒ£ãƒ³ã‚¯æ•°ã¯1-500å€‹ã®ç¯„å›²ã§è¨­å®šã—ã¦ãã ã•ã„");
    }
}
```

### **ğŸ”— æ—¢å­˜ã‚·ã‚¹ãƒ†ãƒ ã¨ã®çµ±åˆ**

#### **BatchOcrIntegrationServiceã®æ‹¡å¼µ**

```csharp
/// <summary>
/// æ™‚é–“è»¸çµ±åˆæ©Ÿèƒ½ã‚’å‚™ãˆãŸå¼·åŒ–ç‰ˆBatchOcrIntegrationService
/// </summary>
public sealed class EnhancedBatchOcrIntegrationService : IDisposable
{
    private readonly IBatchOcrProcessor _batchOcrProcessor;
    private readonly TimedChunkAggregator _chunkAggregator;
    private readonly ITranslationPipelineService _translationPipeline;
    private readonly ILogger<EnhancedBatchOcrIntegrationService> _logger;
    
    public EnhancedBatchOcrIntegrationService(
        IBatchOcrProcessor batchOcrProcessor,
        TimedChunkAggregator chunkAggregator,
        ITranslationPipelineService translationPipeline,
        ILogger<EnhancedBatchOcrIntegrationService> logger)
    {
        _batchOcrProcessor = batchOcrProcessor;
        _chunkAggregator = chunkAggregator;
        _translationPipeline = translationPipeline;
        _logger = logger;
        
        // é›†ç´„å®Œäº†æ™‚ã®å‡¦ç†ã‚’ã‚»ãƒƒãƒˆ
        _chunkAggregator.OnChunksAggregated = OnAggregatedChunksReady;
    }

    /// <summary>
    /// ãƒãƒƒãƒ•ã‚¡ãƒªãƒ³ã‚°ä»˜ãOCRå‡¦ç†
    /// </summary>
    public async Task<IReadOnlyList<TextChunk>> ProcessImageWithBufferingAsync(
        IImage image, IntPtr windowHandle, CancellationToken ct = default)
    {
        var chunks = await _batchOcrProcessor.ProcessAsync(image, ct).ConfigureAwait(false);
        
        // å¾“æ¥ï¼šå³åº§ã«ç¿»è¨³å‡¦ç†
        // return chunks;
        
        // æ–°æ–¹å¼ï¼šãƒãƒƒãƒ•ã‚¡ã«è¿½åŠ ï¼ˆéåŒæœŸã§å¾Œã«å‡¦ç†ã•ã‚Œã‚‹ï¼‰
        foreach (var chunk in chunks)
        {
            await _chunkAggregator.TryAddChunkAsync(chunk, ct).ConfigureAwait(false);
        }
        
        // å³åº§ã«ã¯TextChunkã‚’è¿”ã•ãšã€é›†ç´„å¾Œã«ã‚¤ãƒ™ãƒ³ãƒˆã§å‡¦ç†
        // UIå±¤ã§ã®å¾…æ©ŸãŒå¿…è¦ãªå ´åˆã¯ã€TaskCompletionSourceã‚’ä½¿ç”¨ã—ã¦åŒæœŸåŒ–
        return Array.Empty<TextChunk>();
    }

    /// <summary>
    /// é›†ç´„ã•ã‚ŒãŸãƒãƒ£ãƒ³ã‚¯ã®ç¿»è¨³å‡¦ç†
    /// </summary>
    private async Task OnAggregatedChunksReady(List<TextChunk> aggregatedChunks)
    {
        try
        {
            _logger.LogDebug("é›†ç´„ãƒãƒ£ãƒ³ã‚¯ã‚’ç¿»è¨³ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã«é€ä¿¡: {Count}å€‹", aggregatedChunks.Count);
            
            // ç¿»è¨³ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã«é€ä¿¡
            foreach (var chunk in aggregatedChunks)
            {
                await _translationPipeline.ProcessChunkAsync(chunk).ConfigureAwait(false);
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "é›†ç´„ãƒãƒ£ãƒ³ã‚¯ã®ç¿»è¨³å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿ");
        }
    }

    public void Dispose()
    {
        _chunkAggregator?.Dispose();
        _logger?.LogInformation("EnhancedBatchOcrIntegrationService disposed");
    }
}
```

---

## ğŸŸ¡ **é«˜å„ªå…ˆï¼šå¼·åŒ–ãƒã‚¤ã‚ºé™¤å»çµ±åˆ**

### **ğŸ’¡ ç›®çš„ãƒ»åŠ¹æœ**
è£…é£¾è¨˜å·ãƒ»èª¤èªè­˜æ–‡å­—ã®é™¤å»ã«ã‚ˆã‚Šã€ç¿»è¨³ã‚¨ãƒ³ã‚¸ãƒ³ã«æ¸¡ã•ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆå“è³ªã‚’å¤§å¹…å‘ä¸Šã€‚

### **ğŸ—ï¸ å®Ÿè£…å ´æ‰€**
æ—¢å­˜ã®`CoordinateBasedLineBreakProcessor`ã‚’æ‹¡å¼µ

### **ğŸ’» å…·ä½“çš„å®Ÿè£…**

#### **AdvancedTextCleaner ã‚¯ãƒ©ã‚¹**

```csharp
namespace Baketa.Infrastructure.OCR.PostProcessing;

/// <summary>
/// å¼·åŒ–ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°å‡¦ç†
/// è£…é£¾è¨˜å·é™¤å»ãƒ»è¨€èªç‰¹åŒ–å‡¦ç†ãƒ»èª¤èªè­˜ä¿®æ­£ã‚’çµ±åˆ
/// </summary>
public sealed class AdvancedTextCleaner
{
    private readonly ILogger<AdvancedTextCleaner> _logger;
    private readonly AdvancedCleaningSettings _settings;
    
    public AdvancedTextCleaner(
        AdvancedCleaningSettings settings,
        ILogger<AdvancedTextCleaner> logger)
    {
        _settings = settings;
        _logger = logger;
    }
    
    /// <summary>
    /// å¼·åŒ–ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°
    /// </summary>
    public string CleanTextAdvanced(string text, string? detectedLanguage = null)
    {
        if (string.IsNullOrWhiteSpace(text)) return string.Empty;
        
        var originalText = text;
        
        // 1. è£…é£¾è¨˜å·é™¤å»ï¼ˆææ¡ˆæ›¸ã®æ ¸å¿ƒè¦ä»¶ï¼‰
        text = RemoveDecorationSymbols(text);
        
        // 2. è¨€èªç‰¹åŒ–ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°
        text = ApplyLanguageSpecificCleaning(text, detectedLanguage);
        
        // 3. ä¸€èˆ¬çš„ãªèª¤èªè­˜ä¿®æ­£
        text = CorrectCommonMisrecognitions(text);
        
        // 4. ä¸è¦ãªç©ºç™½ãƒ»æ”¹è¡Œã®æ­£è¦åŒ–
        text = NormalizeWhitespace(text);
        
        if (_settings.EnableVerboseLogging && originalText != text)
        {
            _logger.LogTrace("ãƒ†ã‚­ã‚¹ãƒˆã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°: '{Original}' â†’ '{Cleaned}'", 
                originalText, text);
        }
        
        return text.Trim();
    }
    
    /// <summary>
    /// è£…é£¾è¨˜å·ã®é™¤å»ï¼ˆææ¡ˆæ›¸ã§æŒ‡æ‘˜ã•ã‚ŒãŸè£…é£¾è¨˜å·ã‚’é™¤å»ï¼‰
    /// Geminiãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åæ˜ : Regexã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æœ€é©åŒ–
    /// </summary>
    private static readonly Regex DecorationSymbolsRegex = new(@"[â– â—†â”‚â–²â–¼â—€â–¶â€»]", RegexOptions.Compiled);
    
    private string RemoveDecorationSymbols(string text)
    {
        // ææ¡ˆæ›¸ã§æ˜ç¤ºçš„ã«æŒ‡æ‘˜ã•ã‚ŒãŸè£…é£¾è¨˜å·ã‚’é™¤å»ï¼ˆã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿Regexä½¿ç”¨ï¼‰
        return DecorationSymbolsRegex.Replace(text, string.Empty);
    }
    
    /// <summary>
    /// è¨€èªç‰¹åŒ–ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°
    /// </summary>
    private string ApplyLanguageSpecificCleaning(string text, string? language)
    {
        return language?.ToLowerInvariant() switch
        {
            "ja" or "jp" => CleanJapanese(text),
            "en" => CleanEnglish(text),
            "zh" or "zh-cn" or "zh-tw" => CleanChinese(text),
            _ => text // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ãã®ã¾ã¾
        };
    }
    
    // Geminiãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åæ˜ : Regexã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æœ€é©åŒ–ï¼ˆæ—¥æœ¬èªå‡¦ç†ï¼‰
    private static readonly Regex JapaneseNewlineRegex = new(@"[\n\t\r]", RegexOptions.Compiled);
    private static readonly Regex JapaneseExclamationRegex = new(@"[!ï¼]", RegexOptions.Compiled);
    private static readonly Regex JapaneseQuestionRegex = new(@"[?ï¼Ÿ]", RegexOptions.Compiled);
    private static readonly Regex JapaneseTildeRegex = new(@"[~ï½]", RegexOptions.Compiled);
    private static readonly Regex JapaneseWhitespaceRegex = new(@"\s+", RegexOptions.Compiled);
    
    /// <summary>
    /// æ—¥æœ¬èªç‰¹æœ‰ã®ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°
    /// Geminiãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åæ˜ : ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿Regexä½¿ç”¨ã§ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Š
    /// </summary>
    private string CleanJapanese(string text)
    {
        // æ—¥æœ¬èªç‰¹æœ‰ã®ä¸è¦æ–‡å­—é™¤å»ï¼ˆã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿Regexä½¿ç”¨ï¼‰
        text = JapaneseNewlineRegex.Replace(text, string.Empty);
        
        // å…¨è§’ãƒ»åŠè§’çµ±ä¸€ï¼ˆã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿Regexä½¿ç”¨ï¼‰
        text = JapaneseExclamationRegex.Replace(text, "ï¼");
        text = JapaneseQuestionRegex.Replace(text, "ï¼Ÿ");
        text = JapaneseTildeRegex.Replace(text, "ï½");
        
        // ä¸è¦ãªã‚¹ãƒšãƒ¼ã‚¹ã®é™¤å»ï¼ˆæ—¥æœ¬èªã§ã¯åŸºæœ¬çš„ã«ã‚¹ãƒšãƒ¼ã‚¹ä¸è¦ï¼‰
        text = JapaneseWhitespaceRegex.Replace(text, string.Empty);
        
        return text;
    }
    
    // Geminiãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åæ˜ : Regexã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æœ€é©åŒ–ï¼ˆè‹±èªå‡¦ç†ï¼‰
    private static readonly Regex EnglishNewlineRegex = new(@"[\n\t\r]", RegexOptions.Compiled);
    private static readonly Regex EnglishWhitespaceRegex = new(@"\s+", RegexOptions.Compiled);
    private static readonly Regex EnglishLowercaseLRegex = new(@"\bl\b", RegexOptions.Compiled);
    private static readonly Regex EnglishZeroRegex = new(@"\b0\b", RegexOptions.Compiled);
    
    /// <summary>
    /// è‹±èªç‰¹æœ‰ã®ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°
    /// Geminiãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åæ˜ : ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿Regexä½¿ç”¨ã§ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Š
    /// </summary>
    private string CleanEnglish(string text)
    {
        // è‹±èªç‰¹æœ‰ã®ã‚¹ãƒšãƒ¼ã‚¹æ­£è¦åŒ–ï¼ˆã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿Regexä½¿ç”¨ï¼‰
        text = EnglishNewlineRegex.Replace(text, " ");
        text = EnglishWhitespaceRegex.Replace(text, " ");
        
        // ä¸€èˆ¬çš„ãªèª¤èªè­˜ä¿®æ­£ï¼ˆã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿Regexä½¿ç”¨ï¼‰
        text = EnglishLowercaseLRegex.Replace(text, "I"); // å°æ–‡å­—lã‚’å¤§æ–‡å­—Iã«
        text = EnglishZeroRegex.Replace(text, "O"); // æ•°å­—0ã‚’æ–‡å­—Oã«ï¼ˆæ–‡è„ˆã«ã‚ˆã‚‹ï¼‰
        
        return text;
    }
    
    // Geminiãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åæ˜ : Regexã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æœ€é©åŒ–ï¼ˆä¸­å›½èªå‡¦ç†ï¼‰
    private static readonly Regex ChineseNewlineRegex = new(@"[\n\t\r]", RegexOptions.Compiled);
    
    /// <summary>
    /// ä¸­å›½èªç‰¹æœ‰ã®ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°
    /// Geminiãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åæ˜ : ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿Regexä½¿ç”¨ã§ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Š
    /// </summary>
    private string CleanChinese(string text)
    {
        // ä¸­å›½èªç‰¹æœ‰ã®å‡¦ç†ï¼ˆã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿Regexä½¿ç”¨ï¼‰
        text = ChineseNewlineRegex.Replace(text, string.Empty);
        return text;
    }
    
    /// <summary>
    /// ä¸€èˆ¬çš„ãªèª¤èªè­˜ä¿®æ­£
    /// </summary>
    private string CorrectCommonMisrecognitions(string text)
    {
        // ã‚ˆãã‚ã‚‹èª¤èªè­˜ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ä¿®æ­£
        var corrections = new Dictionary<string, string>
        {
            { "rn", "m" },      // "rn"ã‚’"m"ã«
            { "cl", "d" },      // "cl"ã‚’"d"ã«
            { "vv", "w" },      // "vv"ã‚’"w"ã«
        };
        
        foreach (var correction in corrections)
        {
            text = text.Replace(correction.Key, correction.Value);
        }
        
        return text;
    }
    
    // Geminiãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åæ˜ : Regexã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æœ€é©åŒ–ï¼ˆæ­£è¦åŒ–å‡¦ç†ï¼‰
    private static readonly Regex MultipleNewlinesRegex = new(@"\n{3,}", RegexOptions.Compiled);
    private static readonly Regex TrailingWhitespaceRegex = new(@"[ \t]+$", RegexOptions.Compiled | RegexOptions.Multiline);
    private static readonly Regex LeadingWhitespaceRegex = new(@"^[ \t]+", RegexOptions.Compiled | RegexOptions.Multiline);
    
    /// <summary>
    /// ç©ºç™½ãƒ»æ”¹è¡Œã®æ­£è¦åŒ–
    /// Geminiãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åæ˜ : ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿Regexä½¿ç”¨ã§ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Š
    /// </summary>
    private string NormalizeWhitespace(string text)
    {
        // é€£ç¶šã™ã‚‹æ”¹è¡Œã‚’å˜ä¸€ã«ï¼ˆã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿Regexä½¿ç”¨ï¼‰
        text = MultipleNewlinesRegex.Replace(text, "\n\n");
        
        // è¡Œæœ«ãƒ»è¡Œé ­ã®ä¸è¦ãªç©ºç™½ã‚’é™¤å»ï¼ˆã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿Regexä½¿ç”¨ï¼‰
        text = TrailingWhitespaceRegex.Replace(text, string.Empty);
        text = LeadingWhitespaceRegex.Replace(text, string.Empty);
        
        return text;
    }
}

/// <summary>
/// AdvancedTextCleanerã®è¨­å®š
/// </summary>
public sealed class AdvancedCleaningSettings
{
    public bool EnableVerboseLogging { get; init; } = false;
    public bool EnableLanguageSpecificCleaning { get; init; } = true;
    public bool EnableMisrecognitionCorrection { get; init; } = true;
    
    public static AdvancedCleaningSettings Default => new();
}
```

#### **CoordinateBasedLineBreakProcessorã®æ‹¡å¼µ**

```csharp
/// <summary>
/// å¼·åŒ–ã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°æ©Ÿèƒ½ã‚’çµ±åˆã—ãŸCoordinateBasedLineBreakProcessor
/// </summary>
public sealed class CoordinateBasedLineBreakProcessor
{
    private readonly AdvancedTextCleaner _textCleaner;
    private readonly ILogger<CoordinateBasedLineBreakProcessor> _logger;
    private readonly LineBreakSettings _settings;
    
    public CoordinateBasedLineBreakProcessor(
        ILogger<CoordinateBasedLineBreakProcessor> logger,
        AdvancedTextCleaner textCleaner,
        LineBreakSettings? settings = null)
    {
        _logger = logger;
        _textCleaner = textCleaner;
        _settings = settings ?? LineBreakSettings.Default;
    }
    
    // æ—¢å­˜ã®MergeLineChunksãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ‹¡å¼µ
    private string MergeLineChunks(List<TextChunk> lineChunks)
    {
        if (lineChunks.Count == 0) return string.Empty;
        
        if (lineChunks.Count == 1)
        {
            // ğŸ†• å¼·åŒ–ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°ã‚’é©ç”¨
            var cleanedText = _textCleaner.CleanTextAdvanced(
                lineChunks[0].CombinedText, 
                lineChunks[0].DetectedLanguage);
            return cleanedText;
        }
        
        var result = new StringBuilder();
        
        for (int i = 0; i < lineChunks.Count; i++)
        {
            var chunk = lineChunks[i];
            
            // ğŸ†• å€‹åˆ¥ãƒãƒ£ãƒ³ã‚¯ã‚‚ã‚¯ãƒªãƒ¼ãƒ‹ãƒ³ã‚°
            var cleanedChunkText = _textCleaner.CleanTextAdvanced(
                chunk.CombinedText, chunk.DetectedLanguage);
            
            result.Append(cleanedChunkText);
            
            // æ—¢å­˜ã®ã‚¹ãƒšãƒ¼ã‚¹æŒ¿å…¥ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
            if (i < lineChunks.Count - 1)
            {
                var nextChunk = lineChunks[i + 1];
                var gap = nextChunk.CombinedBounds.X - chunk.CombinedBounds.Right;
                var avgCharWidth = CalculateAverageCharacterWidth(chunk, nextChunk);
                
                if (gap > avgCharWidth * _settings.SpaceInsertionThreshold)
                {
                    result.Append(' ');
                    _logger.LogTrace("ã‚¹ãƒšãƒ¼ã‚¹æŒ¿å…¥: ãƒãƒ£ãƒ³ã‚¯é–“éš” {Gap}px > é–¾å€¤ {Threshold}px", 
                        gap, avgCharWidth * _settings.SpaceInsertionThreshold);
                }
            }
        }
        
        return result.ToString();
    }
    
    // ... ä»–ã®æ—¢å­˜ãƒ¡ã‚½ãƒƒãƒ‰ã¯å¤‰æ›´ãªã—
}
```

---

## ğŸŸ¢ **ä¸­å„ªå…ˆï¼šè¨€èªç‰¹åŒ–å‡¦ç†ï¼ˆæ‹¡å¼µå¯èƒ½è¨­è¨ˆï¼‰**

### **ğŸ’¡ ç›®çš„ãƒ»åŠ¹æœ**
- ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šã®ç¿»è¨³å…ˆè¨€èªã«åŸºã¥ãå‡¦ç†åˆ†å²
- å°†æ¥ã®è¨€èªæ‹¡å¼µã«å¯¾å¿œã—ãŸãƒ—ãƒ©ã‚°ã‚¤ãƒ³å½¢å¼ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### **ğŸ—ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ**

#### **å®Ÿè£…å ´æ‰€**
```
Baketa.Core/Abstractions/Translation/Language/
```

### **ğŸ’» æ‹¡å¼µå¯èƒ½ãªè¨€èªå‡¦ç†è¨­è¨ˆ**

#### **è¨€èªãƒãƒ³ãƒ‰ãƒ©ãƒ¼åŸºåº•ã‚¯ãƒ©ã‚¹**

```csharp
namespace Baketa.Core.Abstractions.Translation.Language;

/// <summary>
/// è¨€èªç‰¹åŒ–å‡¦ç†ã®åŸºåº•ã‚¯ãƒ©ã‚¹
/// æ–°ã—ã„è¨€èªã‚µãƒãƒ¼ãƒˆã¯ã€ã“ã®ã‚¯ãƒ©ã‚¹ã‚’ç¶™æ‰¿ã—ã¦å®Ÿè£…
/// </summary>
public abstract class LanguageProcessorBase
{
    public abstract string LanguageCode { get; }
    public abstract string DisplayName { get; }
    
    /// <summary>
    /// è¨€èªç‰¹åŒ–ã®ãƒ†ã‚­ã‚¹ãƒˆçµåˆ
    /// </summary>
    public abstract string CombineTextChunks(IReadOnlyList<TextChunk> chunks);
    
    /// <summary>
    /// è¨€èªç‰¹åŒ–ã®ãƒ†ã‚­ã‚¹ãƒˆå‰å‡¦ç†
    /// </summary>
    public virtual string PreprocessText(string text) => text;
    
    /// <summary>
    /// è¨€èªç‰¹åŒ–ã®å¾Œå‡¦ç†
    /// </summary>
    public virtual string PostprocessText(string text) => text;
    
    /// <summary>
    /// è¨€èªå›ºæœ‰ã®æ–‡å­—ç¨®åˆ¤å®š
    /// </summary>
    public virtual bool IsNativeScript(char character) => true;
}

/// <summary>
/// æ—¥æœ¬èªå‡¦ç†ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
/// </summary>
public sealed class JapaneseLanguageProcessor : LanguageProcessorBase
{
    public override string LanguageCode => "ja";
    public override string DisplayName => "æ—¥æœ¬èª";
    
    public override string CombineTextChunks(IReadOnlyList<TextChunk> chunks)
    {
        // æ—¥æœ¬èªï¼šç›´æ¥çµåˆï¼ˆã‚¹ãƒšãƒ¼ã‚¹ãªã—ï¼‰
        return string.Join("", chunks.Select(c => c.CombinedText));
    }
    
    public override string PreprocessText(string text)
    {
        // æ—¥æœ¬èªç‰¹æœ‰ã®å‰å‡¦ç†
        text = text.Replace(" ", ""); // ä¸è¦ãªã‚¹ãƒšãƒ¼ã‚¹é™¤å»
        text = Regex.Replace(text, @"[!ï¼]", "ï¼"); // æ„Ÿå˜†ç¬¦çµ±ä¸€
        text = Regex.Replace(text, @"[?ï¼Ÿ]", "ï¼Ÿ"); // ç–‘å•ç¬¦çµ±ä¸€
        return text;
    }
    
    public override bool IsNativeScript(char character)
    {
        // æ—¥æœ¬èªå›ºæœ‰æ–‡å­—ï¼ˆã²ã‚‰ãŒãªãƒ»ã‚«ã‚¿ã‚«ãƒŠãƒ»æ¼¢å­—ãƒ»å¥èª­ç‚¹ï¼‰
        return (character >= 0x3040 && character <= 0x309F) || // ã²ã‚‰ãŒãª
               (character >= 0x30A0 && character <= 0x30FF) || // ã‚«ã‚¿ã‚«ãƒŠ
               (character >= 0x4E00 && character <= 0x9FAF) || // æ¼¢å­—
               "ã€‚ã€ï¼ï¼Ÿ".Contains(character);
    }
}

/// <summary>
/// è‹±èªå‡¦ç†ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
/// </summary>
public sealed class EnglishLanguageProcessor : LanguageProcessorBase
{
    public override string LanguageCode => "en";
    public override string DisplayName => "English";
    
    public override string CombineTextChunks(IReadOnlyList<TextChunk> chunks)
    {
        // è‹±èªï¼šã‚¹ãƒšãƒ¼ã‚¹åŒºåˆ‡ã‚Šã§çµåˆ
        return string.Join(" ", chunks.Select(c => c.CombinedText));
    }
    
    public override string PreprocessText(string text)
    {
        // è‹±èªç‰¹æœ‰ã®å‰å‡¦ç†
        text = Regex.Replace(text, @"\s+", " "); // é€£ç¶šã‚¹ãƒšãƒ¼ã‚¹æ­£è¦åŒ–
        text = text.Trim();
        return text;
    }
    
    public override bool IsNativeScript(char character)
    {
        // è‹±èªå›ºæœ‰æ–‡å­—ï¼ˆã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆãƒ»åŸºæœ¬å¥èª­ç‚¹ï¼‰
        return (character >= 'A' && character <= 'Z') ||
               (character >= 'a' && character <= 'z') ||
               ".,!?;:'\"".Contains(character);
    }
}

/// <summary>
/// ä¸­å›½èªå‡¦ç†ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ï¼ˆå°†æ¥æ‹¡å¼µç”¨ï¼‰
/// </summary>
public sealed class ChineseLanguageProcessor : LanguageProcessorBase
{
    private readonly ChineseVariant _variant;
    
    public ChineseLanguageProcessor(ChineseVariant variant = ChineseVariant.Simplified)
    {
        _variant = variant;
    }
    
    public override string LanguageCode => _variant == ChineseVariant.Simplified ? "zh-cn" : "zh-tw";
    public override string DisplayName => _variant == ChineseVariant.Simplified ? "ç®€ä½“ä¸­æ–‡" : "ç¹é«”ä¸­æ–‡";
    
    public override string CombineTextChunks(IReadOnlyList<TextChunk> chunks)
    {
        // ä¸­å›½èªï¼šç›´æ¥çµåˆï¼ˆæ—¥æœ¬èªã¨åŒæ§˜ï¼‰
        return string.Join("", chunks.Select(c => c.CombinedText));
    }
}

public enum ChineseVariant
{
    Simplified,  // ç®€ä½“
    Traditional // ç¹ä½“
}

/// <summary>
/// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨€èªå‡¦ç†ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ï¼‰
/// </summary>
public sealed class DefaultLanguageProcessor : LanguageProcessorBase
{
    public override string LanguageCode => "default";
    public override string DisplayName => "Default";
    
    public override string CombineTextChunks(IReadOnlyList<TextChunk> chunks)
    {
        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼šã‚¹ãƒšãƒ¼ã‚¹åŒºåˆ‡ã‚Šã§çµåˆ
        return string.Join(" ", chunks.Select(c => c.CombinedText));
    }
}
```

#### **è¨€èªãƒ—ãƒ­ã‚»ãƒƒã‚µãƒ¼ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼**

```csharp
/// <summary>
/// è¨€èªãƒ—ãƒ­ã‚»ãƒƒã‚µãƒ¼ã®ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã‚¤ãƒ³ã‚¿ãƒ¼face
/// </summary>
public interface ILanguageProcessorFactory
{
    LanguageProcessorBase GetProcessor(string languageCode);
    IReadOnlyList<LanguageProcessorBase> GetAllProcessors();
    bool IsLanguageSupported(string languageCode);
}

/// <summary>
/// è¨€èªãƒ—ãƒ­ã‚»ãƒƒã‚µãƒ¼ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã®å®Ÿè£…
/// æ–°ã—ã„è¨€èªã¯ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã§è¿½åŠ ã™ã‚‹ã ã‘ã§æ‹¡å¼µå¯èƒ½
/// </summary>
public sealed class LanguageProcessorFactory : ILanguageProcessorFactory
{
    private readonly Dictionary<string, LanguageProcessorBase> _processors;
    private readonly DefaultLanguageProcessor _defaultProcessor;
    
    public LanguageProcessorFactory()
    {
        _defaultProcessor = new DefaultLanguageProcessor();
        
        _processors = new Dictionary<string, LanguageProcessorBase>(StringComparer.OrdinalIgnoreCase)
        {
            { "ja", new JapaneseLanguageProcessor() },
            { "en", new EnglishLanguageProcessor() },
            { "zh-cn", new ChineseLanguageProcessor(ChineseVariant.Simplified) },
            { "zh-tw", new ChineseLanguageProcessor(ChineseVariant.Traditional) },
            
            // ğŸ“ æ–°è¨€èªã¯ã“ã“ã«è¿½åŠ ã™ã‚‹ã ã‘ã§æ‹¡å¼µå¯èƒ½
            // { "ko", new KoreanLanguageProcessor() },      // éŸ“å›½èªï¼ˆå°†æ¥è¿½åŠ ï¼‰
            // { "fr", new FrenchLanguageProcessor() },      // ãƒ•ãƒ©ãƒ³ã‚¹èªï¼ˆå°†æ¥è¿½åŠ ï¼‰
            // { "de", new GermanLanguageProcessor() },      // ãƒ‰ã‚¤ãƒ„èªï¼ˆå°†æ¥è¿½åŠ ï¼‰
        };
    }
    
    public LanguageProcessorBase GetProcessor(string languageCode)
    {
        if (string.IsNullOrWhiteSpace(languageCode))
            return _defaultProcessor;
        
        return _processors.TryGetValue(languageCode, out var processor) 
            ? processor 
            : _defaultProcessor;
    }
    
    public IReadOnlyList<LanguageProcessorBase> GetAllProcessors()
    {
        return _processors.Values.ToList();
    }
    
    public bool IsLanguageSupported(string languageCode)
    {
        return !string.IsNullOrWhiteSpace(languageCode) && 
               _processors.ContainsKey(languageCode);
    }
}
```

#### **ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šã‚·ã‚¹ãƒ†ãƒ ã¨ã®çµ±åˆ**

```csharp
/// <summary>
/// ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šã‚’è€ƒæ…®ã—ãŸè¨€èªèªè­˜ãƒ†ã‚­ã‚¹ãƒˆå‡¦ç†
/// </summary>
public sealed class LanguageAwareTextProcessor
{
    private readonly ILanguageProcessorFactory _processorFactory;
    private readonly LanguagePairSelectionViewModel _languageSettings;
    private readonly ILogger<LanguageAwareTextProcessor> _logger;
    
    public LanguageAwareTextProcessor(
        ILanguageProcessorFactory processorFactory,
        LanguagePairSelectionViewModel languageSettings,
        ILogger<LanguageAwareTextProcessor> logger)
    {
        _processorFactory = processorFactory;
        _languageSettings = languageSettings;
        _logger = logger;
    }
    
    /// <summary>
    /// ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šè¨€èªã«åŸºã¥ãå‡¦ç†
    /// </summary>
    public string ProcessTextChunks(IReadOnlyList<TextChunk> chunks)
    {
        if (chunks.Count == 0) return string.Empty;
        
        // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ç¿»è¨³å…ˆè¨€èªè¨­å®šã‚’å–å¾—
        var targetLanguage = ExtractTargetLanguageFromUserSettings();
        
        // å¯¾å¿œã™ã‚‹è¨€èªãƒ—ãƒ­ã‚»ãƒƒã‚µãƒ¼ã‚’å–å¾—
        var processor = _processorFactory.GetProcessor(targetLanguage);
        
        _logger.LogDebug("è¨€èªç‰¹åŒ–å‡¦ç†å®Ÿè¡Œ: {TargetLanguage} ({ProcessorType})", 
            targetLanguage, processor.GetType().Name);
        
        // è¨€èªç‰¹åŒ–å‡¦ç†ã‚’å®Ÿè¡Œ
        var combinedText = processor.CombineTextChunks(chunks);
        return processor.PreprocessText(combinedText);
    }
    
    /// <summary>
    /// ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šã‹ã‚‰ç¿»è¨³å…ˆè¨€èªã‚’æŠ½å‡º
    /// </summary>
    private string ExtractTargetLanguageFromUserSettings()
    {
        var languagePair = _languageSettings.SelectedLanguagePair?.LanguagePairKey ?? "ja-en";
        
        // "ja-en" â†’ "en" (ç¿»è¨³å…ˆè¨€èª)
        // "en-ja" â†’ "ja" (ç¿»è¨³å…ˆè¨€èª)
        var parts = languagePair.Split('-');
        if (parts.Length >= 2)
        {
            return parts[1]; // ç¿»è¨³å…ˆè¨€èª
        }
        
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        return "en";
    }
    
    /// <summary>
    /// ç¿»è¨³çµæœã®å¾Œå‡¦ç†
    /// </summary>
    public string PostprocessTranslationResult(string translatedText, string targetLanguage)
    {
        var processor = _processorFactory.GetProcessor(targetLanguage);
        return processor.PostprocessText(translatedText);
    }
}
```

---

## ğŸ“… **å®Ÿè£…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«**

### **Week 1: TimedChunkAggregator å®Ÿè£…**
- **Day 1-2**: ã‚³ã‚¢å®Ÿè£… (`TimedChunkAggregator`, `TimedAggregatorSettings`)
- **Day 3-4**: `BatchOcrIntegrationService`çµ±åˆ
- **Day 5**: çµ±åˆãƒ†ã‚¹ãƒˆãƒ»ãƒ‡ãƒãƒƒã‚°

### **Week 2 å‰åŠ: å¼·åŒ–ãƒã‚¤ã‚ºé™¤å»**
- **Day 1-2**: `AdvancedTextCleaner`å®Ÿè£…
- **Day 3**: `CoordinateBasedLineBreakProcessor`çµ±åˆãƒ»ãƒ†ã‚¹ãƒˆ

### **Week 2 å¾ŒåŠ: è¨€èªç‰¹åŒ–å‡¦ç†**
- **Day 4-5**: è¨€èªãƒ—ãƒ­ã‚»ãƒƒã‚µãƒ¼ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£å®Ÿè£…

### **Week 3: çµ±åˆãƒ†ã‚¹ãƒˆãƒ»æœ€é©åŒ–**
- å…¨æ©Ÿèƒ½çµ±åˆãƒ†ã‚¹ãƒˆ
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ†ã‚¹ãƒˆ

---

## ğŸ”§ **DIç™»éŒ²ãƒ»è¨­å®š**

### **ã‚µãƒ¼ãƒ“ã‚¹ç™»éŒ²ä¾‹**

```csharp
// DIã‚³ãƒ³ãƒ†ãƒŠç™»éŒ²
public static class TranslationQualityServiceExtensions
{
    public static IServiceCollection AddTranslationQualityImprovement(
        this IServiceCollection services)
    {
        // ç’°å¢ƒåˆ¥è¨­å®šã‚’ä½¿ç”¨ï¼ˆFeature Flagã§æ®µéšçš„å°å…¥ï¼‰
        services.AddSingleton(
#if DEBUG
            TimedAggregatorSettings.Development
#else
            TimedAggregatorSettings.Production
#endif
        );
        
        services.AddSingleton(AdvancedCleaningSettings.Default);
        
        // æ ¸å¿ƒã‚µãƒ¼ãƒ“ã‚¹
        services.AddSingleton<TimedChunkAggregator>();
        services.AddSingleton<AdvancedTextCleaner>();
        services.AddSingleton<ILanguageProcessorFactory, LanguageProcessorFactory>();
        services.AddTransient<LanguageAwareTextProcessor>();
        
        // çµ±åˆã‚µãƒ¼ãƒ“ã‚¹ï¼ˆæ—¢å­˜ã®BatchOcrIntegrationServiceã‚’ç½®ãæ›ãˆï¼‰
        services.AddSingleton<EnhancedBatchOcrIntegrationService>();
        
        return services;
    }
}

// Program.cs ã¾ãŸã¯ Startup.cs
services.AddTranslationQualityImprovement();
```

### **è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ä¾‹ (appsettings.json)**

```json
{
  "TranslationQuality": {
    "TimedAggregator": {
      "BufferDelayMs": 150,
      "MaxChunkCount": 50,
      "ForceFlushMs": 1000
    },
    "AdvancedCleaning": {
      "EnableVerboseLogging": false,
      "EnableLanguageSpecificCleaning": true,
      "EnableMisrecognitionCorrection": true
    }
  }
}
```

---

## ğŸ“Š **æœŸå¾…ã•ã‚Œã‚‹æˆæœ**

### **å®šé‡çš„æ”¹å–„ç›®æ¨™**

| é …ç›® | æ”¹å–„å‰ | æ”¹å–„å¾Œ | å‘ä¸Šç‡ |
|------|--------|--------|--------|
| **ç¿»è¨³å“è³ª** | å€‹åˆ¥ãƒãƒ£ãƒ³ã‚¯ç¿»è¨³ | æ–‡è„ˆçµ±åˆç¿»è¨³ | **40-60%å‘ä¸Š** |
| **OCRç²¾åº¦** | ãƒã‚¤ã‚ºä»˜ããƒ†ã‚­ã‚¹ãƒˆ | ã‚¯ãƒªãƒ¼ãƒ³åŒ–ãƒ†ã‚­ã‚¹ãƒˆ | **20-30%å‘ä¸Š** |
| **å¤šè¨€èªå¯¾å¿œ** | æ±ç”¨å‡¦ç†ã®ã¿ | è¨€èªç‰¹åŒ–å‡¦ç† | **è‡ªç„¶æ€§å¤§å¹…å‘ä¸Š** |
| **ä½“æ„Ÿé€Ÿåº¦** | ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ  | 150msé…å»¶ | **çŸ¥è¦šå·®ãªã—** |
| **ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡** | ãƒãƒ£ãƒ³ã‚¯è“„ç©ãªã— | åˆ¶å¾¡ã•ã‚ŒãŸè“„ç© | **é©åˆ‡ãªåˆ¶å¾¡** |

### **å®šæ€§çš„æ”¹å–„åŠ¹æœ**

1. **ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã®å‘ä¸Š**
   - ã‚ˆã‚Šè‡ªç„¶ã§èª­ã¿ã‚„ã™ã„ç¿»è¨³çµæœ
   - æ–‡è„ˆã‚’è€ƒæ…®ã—ãŸä¸€è²«æ€§ã®ã‚ã‚‹ç¿»è¨³
   - è¨€èªå›ºæœ‰ã®è¡¨ç¾ã«é…æ…®ã—ãŸå‡¦ç†

2. **ã‚·ã‚¹ãƒ†ãƒ ã®æ‹¡å¼µæ€§å‘ä¸Š**
   - æ–°è¨€èªè¿½åŠ ãŒå®¹æ˜“ãªãƒ—ãƒ©ã‚°ã‚¤ãƒ³å½¢å¼
   - è¨­å®šå¤‰æ›´ã«ã‚ˆã‚‹èª¿æ•´å¯èƒ½æ€§
   - å°†æ¥ã®æ©Ÿèƒ½æ‹¡å¼µã¸ã®å¯¾å¿œåŠ›

3. **ä¿å®ˆæ€§ã®å‘ä¸Š**
   - è²¬ä»»åˆ†é›¢ã®æ˜ç¢ºåŒ–
   - ãƒ†ã‚¹ãƒˆã—ã‚„ã™ã„ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£
   - ãƒ­ã‚°ã«ã‚ˆã‚‹è¿½è·¡å¯èƒ½æ€§

**ç·åˆçš„ã«ã€ç¿»è¨³ã‚·ã‚¹ãƒ†ãƒ å…¨ä½“ã§60-80%ã®å“è³ªå‘ä¸ŠãŒæœŸå¾…ã•ã‚Œã¾ã™ã€‚**

---

## ğŸš¨ **ãƒªã‚¹ã‚¯ç®¡ç†ã¨å¯¾ç­–**

### **æŠ€è¡“ãƒªã‚¹ã‚¯**

1. **ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯**: TimedChunkAggregatorã§ã®ãƒãƒ£ãƒ³ã‚¯è“„ç©
   - **å¯¾ç­–**: MaxChunkCountåˆ¶é™ã€å®šæœŸçš„ãªå¼·åˆ¶ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
   
2. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**: 150msã®é…å»¶ã«ã‚ˆã‚‹ä½“æ„Ÿé€Ÿåº¦ä½ä¸‹
   - **å¯¾ç­–**: ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šå¯èƒ½ã€æ®µéšçš„èª¿æ•´æ©Ÿèƒ½

3. **çµ±åˆè¤‡é›‘æ€§**: æ—¢å­˜ã‚·ã‚¹ãƒ†ãƒ ã¨ã®çµ±åˆæ™‚ã®ä¸å…·åˆ
   - **å¯¾ç­–**: æ®µéšçš„ãƒ­ãƒ¼ãƒ«ã‚¢ã‚¦ãƒˆã€ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ãƒ•ãƒ©ã‚°

### **é‹ç”¨ãƒªã‚¹ã‚¯**

1. **è¨­å®šãƒŸã‚¹**: ä¸é©åˆ‡ãªé…å»¶æ™‚é–“è¨­å®š
   - **å¯¾ç­–**: ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã®æ…é‡ãªé¸æŠã€è¨­å®šUIæ•´å‚™
   
2. **è¨€èªåˆ¤å®šãƒŸã‚¹**: èª¤ã£ãŸè¨€èªãƒ—ãƒ­ã‚»ãƒƒã‚µãƒ¼é¸æŠ
   - **å¯¾ç­–**: ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ©Ÿèƒ½ã€ãƒ­ã‚°ã«ã‚ˆã‚‹è¿½è·¡

---

## ğŸ“š **é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ**

- [æ—¢å­˜ç¿»è¨³ã‚·ã‚¹ãƒ†ãƒ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£](./translation-interfaces.md)
- [OCRã‚·ã‚¹ãƒ†ãƒ å®Ÿè£…ä»•æ§˜](../ocr-system/ocr-implementation.md)
- [ReactiveUIè¨­å®šã‚·ã‚¹ãƒ†ãƒ ](../ui-system/reactiveui-guide.md)
- [ã‚¤ãƒ™ãƒ³ãƒˆé›†ç´„ã‚·ã‚¹ãƒ†ãƒ ](../event-system/event-system-overview.md)

---

## ğŸš€ **UltraThink + Geminiåˆ†æã«ã‚ˆã‚‹å®Ÿè£…æˆ¦ç•¥**

### **æ–°è¦è¿½åŠ è¦ä»¶ï¼ˆUltraThink Phase 4.9å¯¾å¿œï¼‰**

å‰å›ã®UltraThinkåˆ†æã«ã‚ˆã‚Šã€ä»¥ä¸‹ã®2ã¤ã®é‡è¦ãªUXå•é¡ŒãŒç‰¹å®šã•ã‚Œã¾ã—ãŸï¼š

#### **A. ç¿»è¨³ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ä½ç½®ãšã‚Œå•é¡Œ**
- **ç¾çŠ¶**: `CalculateOptimalOverlayPosition` ã®6æ®µéšæˆ¦ç•¥ã§ã‚‚ä½ç½®ãšã‚ŒãŒç™ºç”Ÿ
- **æ ¹æœ¬åŸå› **: DPIã‚¹ã‚±ãƒ¼ãƒ«ãƒ»è¤‡æ•°ãƒ¢ãƒ‹ã‚¿ãƒ¼ãƒ»ã‚²ãƒ¼ãƒ åº§æ¨™ç³»ã®è¤‡åˆçš„å•é¡Œ
- **è§£æ±ºæ–¹é‡**: 8æ®µéšç²¾å¯†ä½ç½®èª¿æ•´æˆ¦ç•¥ã®å®Ÿè£…

#### **B. ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤æ®‹å­˜å•é¡Œ**  
- **ç¾çŠ¶**: ãƒ†ã‚­ã‚¹ãƒˆãŒæ¶ˆãˆã¦ã‚‚ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ãŒæ®‹ã‚Šç¶šã‘ã‚‹
- **æ ¹æœ¬åŸå› **: ç”»åƒå¤‰åŒ–æ¤œçŸ¥ã¨ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ç®¡ç†ã®åˆ†é›¢
- **è§£æ±ºæ–¹é‡**: ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•å‹è‡ªå‹•æ¶ˆå»ã‚·ã‚¹ãƒ†ãƒ ã®å®Ÿè£…

### **Geminiã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆåˆ†æçµæœ**

```
å„ªå…ˆåº¦è©•ä¾¡ï¼ˆGeminiæ¨å¥¨ï¼‰:
Bï¼ˆã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤è‡ªå‹•æ¶ˆå»ï¼‰> Aï¼ˆç²¾å¯†ä½ç½®èª¿æ•´ï¼‰> Cï¼ˆTimedChunkAggregatorï¼‰

ç†ç”±:
- B: æœ€ã‚‚ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ãªUXå•é¡Œã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ã‚’ç›´æ¥é˜»å®³
- A: è¦–èªæ€§ã«ç›´æ¥å½±éŸ¿ã€ç¿»è¨³ã‚·ã‚¹ãƒ†ãƒ ã®åŸºæœ¬æ©Ÿèƒ½
- C: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã€åŸºæœ¬æ©Ÿèƒ½ãŒå®‰å®šã—ã¦ã‹ã‚‰å®Ÿè£…
```

## ğŸ“‹ **çµ±åˆå®Ÿè£…è¨ˆç”»ï¼ˆBâ†’Aâ†’Cå„ªå…ˆé †ï¼‰**

### **Phase 1: ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤è‡ªå‹•æ¶ˆå»ã‚·ã‚¹ãƒ†ãƒ ï¼ˆæœ€å„ªå…ˆï¼‰**

**å®Ÿè£…æœŸé–“**: 1é€±é–“
**è²¬ä»»**: `InPlaceTranslationOverlayManager`, `SmartProcessingPipelineService`

#### **1.1 ã‚¤ãƒ™ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ æ‹¡å¼µ**
```csharp
// æ–°è¦ã‚¤ãƒ™ãƒ³ãƒˆ: ãƒ†ã‚­ã‚¹ãƒˆé ˜åŸŸæ¶ˆå¤±æ¤œçŸ¥
public sealed record TextRegionDisappearedEvent(
    IntPtr WindowHandle,
    System.Drawing.Rectangle DisappearedRegion,
    DateTime DetectedAt,
    string RegionId
) : IEvent;
```

#### **1.2 è‡ªå‹•æ¶ˆå»ã‚µãƒ¼ãƒ“ã‚¹å®Ÿè£…**
```csharp
public class AutoOverlayCleanupService : IAutoOverlayCleanupService
{
    private readonly InPlaceTranslationOverlayManager _overlayManager;
    private readonly IEventAggregator _eventAggregator;
    
    public AutoOverlayCleanupService(
        InPlaceTranslationOverlayManager overlayManager,
        IEventAggregator eventAggregator)
    {
        _overlayManager = overlayManager;
        _eventAggregator = eventAggregator;
        
        // ãƒ†ã‚­ã‚¹ãƒˆæ¶ˆå¤±ã‚¤ãƒ™ãƒ³ãƒˆè³¼èª­
        _eventAggregator.Subscribe<TextRegionDisappearedEvent>(HandleTextDisappearedAsync);
    }
    
    private async Task HandleTextDisappearedAsync(TextRegionDisappearedEvent evt)
    {
        await _overlayManager.CleanupOverlaysInRegionAsync(
            evt.WindowHandle, evt.DisappearedRegion).ConfigureAwait(false);
    }
}
```

#### **1.3 çµ±åˆãƒã‚¤ãƒ³ãƒˆ**
- `SmartProcessingPipelineService` ã®Stage 1ï¼ˆç”»åƒå¤‰åŒ–æ¤œçŸ¥ï¼‰ã¨é€£æº
- Perceptual Hashå·®åˆ†ã«ã‚ˆã‚‹é ˜åŸŸç‰¹å®š
- Circuit Breaker ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ã‚ˆã‚‹èª¤æ¤œçŸ¥é˜²æ­¢

### **Phase 2: ç²¾å¯†ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ä½ç½®èª¿æ•´ï¼ˆé«˜å„ªå…ˆï¼‰**

**å®Ÿè£…æœŸé–“**: 1-2é€±é–“  
**è²¬ä»»**: `TextChunk.CalculateOptimalOverlayPosition`

#### **2.1 8æ®µéšç²¾å¯†ä½ç½®èª¿æ•´æˆ¦ç•¥**
```csharp
public System.Drawing.Point CalculateOptimalOverlayPosition(
    System.Drawing.Rectangle screenBounds,
    double dpiScaleX, double dpiScaleY,
    MonitorInfo primaryMonitor)
{
    // Stage 1-2: æ—¢å­˜ã®åŸºæœ¬ä½ç½®èª¿æ•´ï¼ˆå¤‰æ›´ãªã—ï¼‰
    var basePoint = CalculateBasePosition(screenBounds);
    
    // Stage 3: æ–°è¦ - DPIã‚¹ã‚±ãƒ¼ãƒ«è£œæ­£
    var dpiCorrectedPoint = ApplyDpiCorrection(basePoint, dpiScaleX, dpiScaleY);
    
    // Stage 4: æ–°è¦ - ãƒãƒ«ãƒãƒ¢ãƒ‹ã‚¿ãƒ¼åº§æ¨™å¤‰æ›
    var monitorAdjustedPoint = TransformToMonitorCoordinates(dpiCorrectedPoint, primaryMonitor);
    
    // Stage 5-8: ã‚³ãƒªã‚¸ãƒ§ãƒ³å›é¿ï¼ˆæ‹¡å¼µç‰ˆï¼‰
    return ApplyAdvancedCollisionAvoidance(monitorAdjustedPoint, screenBounds);
}

private System.Drawing.Point ApplyDpiCorrection(System.Drawing.Point point, double scaleX, double scaleY)
{
    return new System.Drawing.Point(
        (int)(point.X * scaleX),
        (int)(point.Y * scaleY)
    );
}
```

#### **2.2 DPI/ãƒãƒ«ãƒãƒ¢ãƒ‹ã‚¿ãƒ¼å¯¾å¿œ**
- Windows DPI APIçµ±åˆ (`GetDpiForWindow`, `GetSystemDpiForProcess`)
- ãƒ¢ãƒ‹ã‚¿ãƒ¼åº§æ¨™ç³»å¤‰æ› (`MonitorFromPoint`, `GetMonitorInfo`)
- ã‚²ãƒ¼ãƒ åº§æ¨™ç³»è£œæ­£ï¼ˆDirectX/OpenGLåº§æ¨™å¤‰æ›ï¼‰

### **Phase 3: TimedChunkAggregatorçµ±åˆï¼ˆä¸­å„ªå…ˆï¼‰**

**å®Ÿè£…æœŸé–“**: 1-2é€±é–“
**è²¬ä»»**: `TimedChunkAggregatorService`ï¼ˆæ—¢ã«å®Ÿè£…æ¸ˆã¿ï¼‰

#### **3.1 çµ±åˆä½œæ¥­**
- Feature Flag ã‚’ `true` ã«å¤‰æ›´ï¼ˆæ®µéšçš„æœ‰åŠ¹åŒ–ï¼‰
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–ã¨ãƒ­ã‚°åˆ†æ
- å¿…è¦ã«å¿œã˜ãŸè¨­å®šèª¿æ•´ï¼ˆ`BufferDelayMs`, `ForceFlushMs`ï¼‰

#### **3.2 å“è³ªä¿è¨¼**
- A/Bãƒ†ã‚¹ãƒˆå®Ÿæ–½ï¼ˆTimedAggregatoræœ‰ç„¡ã§ã®ç¿»è¨³å“è³ªæ¯”è¼ƒï¼‰
- ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ç›£è¦–ï¼ˆé•·æ™‚é–“å‹•ä½œãƒ†ã‚¹ãƒˆï¼‰
- ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åé›†

## â° **å®Ÿè£…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«è©³ç´°**

| ãƒ•ã‚§ãƒ¼ã‚º | æœŸé–“ | é–‹ç™º | ãƒ†ã‚¹ãƒˆ | ãƒªãƒªãƒ¼ã‚¹ |
|---------|------|------|--------|----------|
| **Phase 1** | Week 1 | 3æ—¥ | 2æ—¥ | - |
| **Phase 2** | Week 2-3 | 5æ—¥ | 3æ—¥ | - |  
| **Phase 3** | Week 4 | 2æ—¥ | 3æ—¥ | Week 5 |
| **çµ±åˆãƒ†ã‚¹ãƒˆ** | Week 5 | - | 5æ—¥ | - |

**ç·å®Ÿè£…æœŸé–“**: 5é€±é–“
**ãƒªãƒªãƒ¼ã‚¹æº–å‚™å®Œäº†**: Week 6

## ğŸ¯ **æˆåŠŸæŒ‡æ¨™ã¨KPI**

### **Phase 1 KPIï¼ˆã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤è‡ªå‹•æ¶ˆå»ï¼‰**
- ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤æ®‹å­˜ç‡: 0% ï¼ˆç›®æ¨™ï¼‰
- èª¤æ¶ˆå»ç‡: <5% ï¼ˆè¨±å®¹ç¯„å›²ï¼‰
- å¿œç­”æ™‚é–“: <100ms ï¼ˆç”»åƒå¤‰åŒ–æ¤œçŸ¥â†’æ¶ˆå»å®Ÿè¡Œï¼‰

### **Phase 2 KPIï¼ˆç²¾å¯†ä½ç½®èª¿æ•´ï¼‰**
- ä½ç½®ãšã‚Œç™ºç”Ÿç‡: <10% ï¼ˆç¾çŠ¶50%ã‹ã‚‰æ”¹å–„ï¼‰
- DPIã‚¹ã‚±ãƒ¼ãƒ«å¯¾å¿œç‡: 100% ï¼ˆå…¨è§£åƒåº¦ï¼‰
- ãƒãƒ«ãƒãƒ¢ãƒ‹ã‚¿ãƒ¼å¯¾å¿œç‡: 100% ï¼ˆ2-4ãƒ¢ãƒ‹ã‚¿ãƒ¼æ§‹æˆï¼‰

### **Phase 3 KPIï¼ˆTimedChunkAggregatorï¼‰**
- ç¿»è¨³å“è³ªå‘ä¸Š: 40-60% ï¼ˆæ–‡è„ˆçµ±åˆåŠ¹æœï¼‰
- ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡å¢—åŠ : <20MB ï¼ˆè¨±å®¹ç¯„å›²ï¼‰
- å‡¦ç†é…å»¶: 150msÂ±50ms ï¼ˆè¨­å®šå€¤ï¼‰

---

## ğŸ”„ **æ›´æ–°å±¥æ­´**

- **v1.0** (2025-09-01): åˆç‰ˆä½œæˆ - ç¿»è¨³ç²¾åº¦å‘ä¸Šæˆ¦ç•¥ã®ç­–å®š
- **v1.1** (2025-09-01): Geminiãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯åæ˜ å®Œäº†
  - SourceWindowHandleåˆ¥ãƒãƒƒãƒ•ã‚¡ç®¡ç†ã«ã‚ˆã‚‹ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆåˆ†é›¢
  - ForceFlushMsåˆ¶å¾¡ã«ã‚ˆã‚‹ç„¡é™ã‚¿ã‚¤ãƒãƒ¼ãƒªã‚»ãƒƒãƒˆé˜²æ­¢
  - async void ãƒ¡ã‚½ãƒƒãƒ‰ã§ã®åŒ…æ‹¬çš„ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
  - Interlocked.Incrementä½¿ç”¨ã«ã‚ˆã‚‹ thread-safe ChunkIDç”Ÿæˆ
  - ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ¸ˆã¿Regexä½¿ç”¨ã«ã‚ˆã‚‹ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
- **v1.2** (2025-01-09): UltraThink Phase 4.9å¯¾å¿œ - æ–°è¦è¦ä»¶çµ±åˆå®Œäº†
  - ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ä½ç½®ãšã‚Œå•é¡Œã®8æ®µéšç²¾å¯†ä½ç½®èª¿æ•´æˆ¦ç•¥ç­–å®š
  - ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤è‡ªå‹•æ¶ˆå»ã‚·ã‚¹ãƒ†ãƒ ã®è©³ç´°è¨­è¨ˆï¼ˆã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•å‹ï¼‰
  - Geminiã‚¨ã‚­ã‚¹ãƒ‘ãƒ¼ãƒˆåˆ†æã«ã‚ˆã‚‹å„ªå…ˆåº¦å†ç·¨æˆï¼ˆBâ†’Aâ†’Cé †ï¼‰
  - 5é€±é–“ã®è©³ç´°å®Ÿè£…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã¨æˆåŠŸæŒ‡æ¨™KPIç­–å®š
  - DPI/ãƒãƒ«ãƒãƒ¢ãƒ‹ã‚¿ãƒ¼å¯¾å¿œã¨Windows APIçµ±åˆä»•æ§˜è¿½åŠ 
- **v1.3** (2025-01-09): ğŸ‰ **Phase 1 å®Œäº†ç‰ˆ** - ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤è‡ªå‹•æ¶ˆå»ã‚·ã‚¹ãƒ†ãƒ å®Ÿè£…å®Œäº†
  - âœ… **AutoOverlayCleanupServiceå®Ÿè£…å®Œäº†**: Circuit Breaker + IHostedServiceçµ±åˆ
  - âœ… **TextDisappearanceEventæ‹¡å¼µå®Œäº†**: RegionId, ConfidenceScore ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£è¿½åŠ 
  - âœ… **å‹•çš„ä¿¡é ¼åº¦è¨ˆç®—å®Ÿè£…**: æ¤œçŸ¥ã‚¹ãƒ†ãƒ¼ã‚¸ã¨å¤‰åŒ–ç‡ã‚’è€ƒæ…®ã—ãŸç²¾å¯†ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°
  - âœ… **è¨­å®šå¤–éƒ¨åŒ–å®Œäº†**: appsettings.json ã«ã‚ˆã‚‹æœ¬ç•ªç’°å¢ƒèª¿æ•´æ©Ÿèƒ½
  - âœ… **åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆå®Œäº†**: 15/15ãƒ†ã‚¹ãƒˆæˆåŠŸï¼ˆ100%ãƒ‘ã‚¹ç‡ï¼‰
  - âœ… **Geminiãƒ¬ãƒ“ãƒ¥ãƒ¼å®Œäº†**: å°‚é–€å®¶ã«ã‚ˆã‚‹å…¨æŒ‡æ‘˜äº‹é …å¯¾å¿œæ¸ˆã¿
  - **æ¬¡æœŸå„ªå…ˆäº‹é …**: Phase 2ï¼ˆç²¾å¯†ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ä½ç½®åˆ¶å¾¡ï¼‰ã¸ã®ç§»è¡Œæº–å‚™å®Œäº†

---

**ã“ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã¯ã€Baketaã®ç¿»è¨³å“è³ªã‚’æ¬¡ã®ãƒ¬ãƒ™ãƒ«ã«æŠ¼ã—ä¸Šã’ã‚‹ãŸã‚ã®åŒ…æ‹¬çš„ãªå®Ÿè£…æˆ¦ç•¥ã‚’æä¾›ã—ã¾ã™ã€‚æ®µéšçš„ãªå®Ÿè£…ã«ã‚ˆã‚Šã€ãƒªã‚¹ã‚¯ã‚’æœ€å°é™ã«æŠ‘ãˆãªãŒã‚‰å¤§å¹…ãªå“è³ªå‘ä¸Šã‚’å®Ÿç¾ã§ãã¾ã™ã€‚**