# 段階的ROIキャプチャシステム実装要件

## 背景・課題

### 現在の大画面キャプチャ失敗の複合的原因
実測検証により、当初のメモリ仮説を修正：

#### 1. 検証で判明した事実
- **メモリ使用量**: すべてのウィンドウサイズで435MB安定（予想された大量消費なし）
- **処理安定性**: 大画面でもプロセス安定、メモリスパイクなし
- **失敗の真因**: メモリ不足以外の技術的制約が存在

#### 2. 特定された実際の制約
- **GPUテクスチャサイズ制限**: `MaximumTexture2DDimension`によるハードウェア上限
- **単一サーフェスメモリ制限**: WDDM制約による割り当て上限
- **TDR (Timeout Detection and Recovery)**: GPU処理タイムアウトによる強制中断
- **PCIeバス帯域幅制限**: 高解像度データ転送のボトルネック
- **ドライババージョン依存**: Windows Updateによる挙動変化

#### 3. 従来のメモリ仮説の修正
- **11MB一括確保**: 実際には問題とならない（プロセス全体で435MB安定）
- **GPU→CPU転送**: 大量データ転送自体は実行可能
- **真の制約**: より深いレベルでの技術的制限が存在

### 解決アプローチ
**適応的キャプチャシステム**: GPU環境に応じて最適な手法を自動選択し、どの環境でも確実に動作するハイブリッドアプローチ

#### 戦略の再定義（GPU種別対応版）
1. **環境適応**: GPU種別（統合/専用/なし）に応じた最適手法の自動選択
2. **確実な動作**: どのハードウェア構成でも必ず何らかの方法でキャプチャ成功
3. **段階的フォールバック**: 高性能手法→中性能手法→確実な手法の多段階切り替え
4. **処理効率最適化**: 環境に応じたOCR処理とキャプチャサイズの動的調整

## 技術要件

### 1. 適応的キャプチャシステム

#### 1.1 GPU環境検出・分類
- **統合GPU検出**: Intel HD Graphics、AMD APU等の統合GPU識別
- **専用GPU検出**: NVIDIA、AMD、Intel Arc等の専用GPU識別
- **マルチGPU環境**: 統合GPU+専用GPU環境での最適GPU自動選択
- **テクスチャサイズ制限**: `D3D11_FEATURE_DATA_D3D10_X_HARDWARE_OPTIONS.MaximumTexture2DDimension`確認
- **ソフトウェアレンダリング**: D3D_DRIVER_TYPE_WARPの利用可否判定
- **DirectX対応レベル**: DirectX 11対応状況とfeature levelの確認

#### 1.2 環境別最適化戦略
**統合GPU環境（最も効率的）:**
- **直接大画面キャプチャ**: システムメモリ共有による高効率処理
- **フル解像度処理**: メモリ転送オーバーヘッドが少ないため直接処理
- **最高速度**: PCIeバス転送なしでの最適パフォーマンス

**専用GPU環境（段階的処理）:**
- **軽量スキャン**: 1/4解像度での高速プレスキャン
- **ROI検出**: テキスト領域特定による効率化
- **部分高解像度**: 特定領域のみ高解像度キャプチャ

**ソフトウェアレンダリング（確実動作）:**
- **PrintWindow API**: 最も確実だが低速な手法
- **GDI キャプチャ**: 古いシステムでも確実に動作
- **段階的品質調整**: 解像度を下げて確実にキャプチャ

### 2. 自動テキスト領域検出システム

#### 2.1 軽量画像解析
- **OpenCVベース高速検出**: 低解像度画像でのエッジ検出・輪郭抽出
- **テキスト候補フィルタリング**: サイズ・アスペクト比・密度による絞り込み
- **領域統合**: 近接する文字・単語領域のテキストブロック化
- **座標スケーリング**: 低解像度→高解像度への正確な座標変換

#### 2.2 適応的領域管理
- **動的領域調整**: テキスト位置変化の自動追跡機能
- **信頼度ベース選択**: 検出信頼度の高い領域を優先処理
- **履歴ベース最適化**: 過去の検出履歴からよく使用される領域を学習

### 3. 既存アーキテクチャ統合

#### 3.1 適応的キャプチャインターフェース
```csharp
// 適応的キャプチャサービス - GPU環境に応じて最適手法を選択
public interface IAdaptiveCaptureService
{
    Task<AdaptiveCaptureResult> CaptureAsync(IntPtr hwnd, CaptureOptions options);
    Task<GPUEnvironmentInfo> DetectGPUEnvironmentAsync();
    Task<ICaptureStrategy> SelectOptimalStrategyAsync(IntPtr hwnd);
}

public class AdaptiveCaptureResult
{
    public IList<IWindowsImage> CapturedImages { get; set; }
    public CaptureStrategyUsed StrategyUsed { get; set; }
    public GPUEnvironmentInfo GPUEnvironment { get; set; }
    public bool Success { get; set; }
    public TimeSpan ProcessingTime { get; set; }
    public string[] FallbacksAttempted { get; set; }
}

public enum CaptureStrategyUsed
{
    DirectFullScreen,      // 統合GPU：直接大画面キャプチャ
    ROIBased,             // 専用GPU：段階的ROIキャプチャ  
    PrintWindowFallback,   // ソフトウェア：確実動作保証
    GDIFallback           // 最終手段：古いシステム対応
}

public class GPUEnvironmentInfo
{
    public bool IsIntegratedGPU { get; set; }
    public bool IsDedicatedGPU { get; set; }
    public bool HasDirectX11Support { get; set; }
    public string GPUName { get; set; }
    public long AvailableMemoryMB { get; set; }
    public uint MaximumTexture2DDimension { get; set; }  // ハードウェア制限
    public bool IsMultiGPUEnvironment { get; set; }      // 複数GPU環境
    public bool HasHDRSupport { get; set; }              // HDR対応状況
    public string ColorSpaceSupport { get; set; }        // 対応色空間
}

public class CaptureOptions
{
    public bool AllowDirectFullScreen { get; set; } = true;
    public bool AllowROIProcessing { get; set; } = true; 
    public bool AllowSoftwareFallback { get; set; } = true;
    public float ROIScaleFactor { get; set; } = 0.25f;
    public int MaxRetryAttempts { get; set; } = 3;
}
```

#### 3.2 ネイティブキャプチャ拡張
```cpp
// WindowsCaptureSession.h への追加
class WindowsCaptureSession {
    // 既存機能...
    
    // 新規：低解像度キャプチャ機能
    bool CreateLowResFramePool(float scaleFactor);
    bool CaptureLowResFrame(unsigned char** bgraData, int* width, int* height, 
                           int* stride, long long* timestamp, int timeoutMs);
    
    // 新規：部分領域キャプチャ機能
    bool CaptureRegion(const RECT& region, unsigned char** bgraData, 
                      int* width, int* height, int* stride, long long* timestamp);
};
```

#### 3.3 既存システムとの互換性
- **既存フロー保持**: 従来の全画面キャプチャフローを完全互換で維持
- **段階的適用**: 新しいサービスを選択的に導入可能
- **フォールバック戦略**: 各段階で失敗時の代替手段を準備

## 処理効率向上予想（修正版）

### Stage 1: 軽量全画面スキャン
- **制約回避**: 小さいテクスチャサイズで未知のDirectX制限を回避
- **処理安定化**: Direct3D フレームプール作成成功率の向上
- **処理時間短縮**: 640x270処理により数百ミリ秒での完了
- **リソース効率**: GPU処理負荷の大幅軽減

### Stage 2: 部分高解像度キャプチャ  
- **対象領域最適化**: 全画面(2.7M pixels) → テキスト領域群(合計500K pixels程度)
- **段階的制約特定**: 各環境での最大キャプチャ可能サイズを動的決定
- **並列処理**: 複数の小領域を並列で安全にキャプチャ
- **OCR効率**: 背景ノイズ除去による認識精度向上

### OCR処理最適化
- **PP-OCRv5タイムアウト解消**: 45秒 → 3-5秒に短縮（部分画像処理）
- **並列OCR処理**: 複数のテキスト領域を並列でOCR実行
- **精度向上**: テキスト以外の背景要素除去による認識精度向上

### システム安定性向上
- **未知制約への対応**: 環境固有の制約を段階的処理で回避
- **動的適応**: システム制限に応じた最適なキャプチャサイズ自動調整
- **複数フォールバック**: 各段階での失敗に対する代替手段確保

## 実装フェーズ

### Phase 1: 適応的キャプチャ基盤実装
1. **GPU環境検出システム** - ハードウェア環境の自動識別
   - `GPUEnvironmentDetector` 実装
   - DirectX 11対応レベル確認
   - 統合GPU/専用GPU/ソフトウェアレンダリング分類

2. **戦略選択システム** - 環境に応じた最適手法選択
   - `ICaptureStrategy` インターフェース定義
   - 各環境用戦略クラス実装（DirectFullScreen, ROIBased, PrintWindowFallback）
   - 動的戦略切り替え機能

3. **フォールバック機構** - 確実動作保証システム
   - 多段階フォールバック（高性能→確実動作）
   - エラー分析による次善策自動選択
   - TDR検出とリカバリ機能
   - ログ・診断情報の詳細記録

### Phase 2: 高解像度部分キャプチャ実装
1. **部分領域キャプチャ機能** - 検出領域の高解像度キャプチャ
   - ネイティブ部分キャプチャ実装
   - 座標変換（低解像度→高解像度）の正確性確保
   - 複数領域の並列処理対応

2. **統合キャプチャフロー** - 段階的処理の統合
   - 軽量スキャン→検出→部分キャプチャの一連フロー
   - 各段階での失敗時のフォールバック戦略
   - パフォーマンス測定・ロギング機能

3. **既存システム統合** - 現在のOCR・翻訳フローとの統合
   - 段階的キャプチャ結果のOCRエンジン連携
   - 複数テキスト領域の並列OCR処理対応

### Phase 3: 高度最適化・運用機能
1. **適応的パラメータ調整** - 画面・ゲームに応じた自動最適化
   - スケールファクター動的調整
   - 領域検出パラメータの学習機能
   - ゲーム特有パターンの学習

2. **パフォーマンス分析・チューニング** - 処理効率の測定・改善
   - 段階別処理時間の詳細測定
   - ボトルネック特定と最適化
   - メモリ使用量監視機能

## リスクと対策

### 1. テキスト検出失敗への対策

#### 1.1 低解像度スキャンの限界
**リスク**: 小さい文字、特殊フォント、低コントラスト背景でのテキスト見逃し

**対策**:
- **履歴ベースキャッシュ**: 前回成功した領域情報を保持・再利用
- **手動再スキャン機能**: ユーザー操作による強制全画面スキャン実行
- **多段階検出**: エッジ検出→輪郭抽出→テキスト性判定の複数フィルター
- **検出パラメータ調整**: ゲーム種別に応じた検出閾値の動的調整

```csharp
public class TextRegionCache
{
    public IList<Rectangle> GetCachedRegions(string applicationName);
    public void UpdateSuccessfulRegions(string applicationName, IList<Rectangle> regions);
    public void ClearCacheOnUserRequest();
}
```

#### 1.2 動的UIへの追随性
**リスク**: 高速スクロール、フェードイン・アウト、位置変化への対応不足

**対策**:
- **差分キャプチャ**: 前フレームとの差分による変化領域検出
- **予測的領域拡張**: テキスト移動方向を予測した領域設定
- **フレームバッファリング**: 複数フレームの情報を組み合わせた安定化
- **動的追跡**: オプティカルフローによるテキスト領域追跡

### 2. パフォーマンス劣化リスク

#### 2.1 段階的処理のオーバーヘッド
**リスク**: 2段階処理により、小ウィンドウでも処理時間が増加

**対策**:
- **適応的処理選択**: ウィンドウサイズに応じた処理方法自動選択
- **並列処理**: 軽量スキャンと前回領域の並列処理
- **キャッシュ最適化**: 高速アクセス可能な領域情報管理

#### 2.2 HDR・色空間対応
**リスク**: HDRコンテンツキャプチャ時の色の白飛び（過飽和）

**対策**:
- **HDR検出**: キャプチャ対象のHDRコンテンツ自動検出
- **トーンマッピング**: HDR→SDR適切変換による色情報正確性確保
- **色空間管理**: sRGB、Display P3等の色空間適切処理

#### 2.3 TDR (Timeout Detection and Recovery)
**リスク**: GPU処理タイムアウトによる強制中断

**対策**:
- **処理時間監視**: GPU処理時間の詳細監視
- **段階的処理**: 大きな処理を小さく分割してTDR回避
- **タイムアウト調整**: レジストリ設定による適切なタイムアウト値設定

## 効果測定（KPI）

### 定量的成功指標

#### 1. キャプチャ成功率
- **目標**: 99.5%以上（大画面ウィンドウ含む）
- **測定方法**: 異なるウィンドウサイズでの成功/失敗統計
- **現状**: 大画面（2560x1080）で不明な制約により失敗、メモリ使用量は435MB安定

#### 2. システム安定性
- **目標**: プロセス安定性維持、予期しないクラッシュゼロ
- **測定方法**: 長時間稼働でのプロセス監視
- **現状**: すべてのウィンドウサイズで435MB安定、メモリスパイクなし

#### 3. 処理時間
- **軽量スキャン**: 500ms未満
- **部分キャプチャ**: 1秒未満（複数領域含む）
- **全体処理時間**: 3秒未満（検出→OCR→翻訳）

#### 4. テキスト領域検出精度
- **再現率**: 95%以上（実際のテキストを検出）
- **適合率**: 90%以上（検出領域にテキストが存在）
- **測定方法**: 手動アノテーション画像との比較評価

### 定性的成功指標
- **ユーザー操作不要**: 自動段階的処理の透明性
- **安定性**: 24時間連続使用でのクラッシュゼロ
- **互換性**: 既存ワークフローとの完全互換

## ユーザー体験（UX）設計

### 1. 処理中の視覚的フィードバック

#### 1.1 段階的処理インジケーター
- **軽量スキャン中**: プログレスバー＋「画面解析中...」
- **テキスト検出中**: 「テキスト領域検索中...」
- **部分キャプチャ中**: 「高解像度キャプチャ実行中...」

#### 1.2 検出領域のハイライト表示
```csharp
public class ROIVisualizationService
{
    public void ShowDetectedRegions(IList<Rectangle> regions, TimeSpan displayDuration);
    public void ShowProcessingProgress(string currentStage, float progress);
    public void ShowCaptureSuccess(int regionsProcessed);
}
```

#### 1.3 Avalonia UI統合
- **リアルタイム状況表示**: 現在の処理段階をステータスバーに表示
- **設定パネル**: 検出パラメーター調整UI
- **診断モード**: 検出領域の可視化とデバッグ情報表示
- **手動制御**: 強制再スキャン、キャッシュクリア、検出感度調整

### 2. エラー回復UX
- **自動リトライ**: 失敗時の自動再試行（最大3回）
- **フォールバック通知**: PrintWindow切り替え時の通知
- **問題報告**: 継続的失敗時の自動ログ送信オプション

## 技術的考慮事項

### 互換性
- **.NET 8 Windows対応**: 既存アーキテクチャとの一貫性
- **Avalonia UI統合**: 視覚的フィードバックとシームレス統合
- **ReactiveUI活用**: UX状態管理での既存パターン継続

### パフォーマンス
- **非同期処理**: すべてのキャプチャ・OCR処理の非同期化
- **メモリ管理**: IDisposableパターンによる適切なリソース解放
- **例外処理**: P/Invoke関連例外の適切なハンドリング

### テスト戦略
- **単体テスト**: ROI計算・領域検出ロジックのテスト
- **統合テスト**: 段階的キャプチャ→OCR→翻訳フローのテスト
- **パフォーマンステスト**: 処理時間・メモリ使用量の継続測定
- **UXテスト**: ユーザー操作フローとフィードバック品質の評価

## 期待効果

### 根本的問題解決
- **大画面キャプチャ失敗**: 未知のDirectX制約を段階的処理で回避
- **システム固有制約**: 環境依存の制限を動的に特定・回避
- **処理効率向上**: 必要領域のみの処理による大幅な効率化
- **安定性確保**: 複数のフォールバック戦略による確実な動作

### 処理効率劇的向上
- **キャプチャ成功率**: 大画面での失敗率ゼロを目指す
- **OCR処理時間**: 45秒タイムアウト → 3-5秒に短縮
- **全体処理時間**: 段階的並列処理による大幅短縮
- **システム安定性**: メモリ・リソース問題解消による安定化

### ユーザー体験向上
- **即座の翻訳開始**: 大画面での待機時間解消
- **認識精度向上**: テキスト領域限定によるノイズ除去効果
- **透明な処理**: ユーザー操作不要の自動段階的処理
- **確実な動作**: 従来失敗していた環境での安定動作

## 実装優先度

### 最優先 (Phase 1): 確実動作保証
- **GPU環境検出**: すべてのハードウェア構成で動作する基盤
- **多段階フォールバック**: どの環境でも必ず何らかの方法でキャプチャ成功
- **戦略自動選択**: ユーザー操作なしで最適手法を選択

### 高優先 (Phase 2): 性能最適化
- **統合GPU最適化**: システムメモリ共有を活用した高速処理
- **専用GPU対応**: ROI処理による効率化
- **既存システム統合**: 現在のOCR・翻訳フローとの完全統合

### 中優先 (Phase 3): 高度化・学習機能
- **環境学習**: 使用パターンによる戦略選択精度向上
- **パフォーマンス分析**: 詳細測定と継続改善
- **予測的最適化**: 過去の成功パターンに基づく先行最適化

---

## まとめ

この**段階的ROIキャプチャシステム**により、現在のBaketaが抱える大画面キャプチャ問題を技術的に根本解決できます。

**核心的解決策（GPU種別対応版）:**
1. **環境適応型戦略**: 統合GPU（直接）、専用GPU（ROI）、ソフトウェア（確実）の自動選択
2. **多段階フォールバック**: 高性能手法から確実動作まで段階的切り替え
3. **確実動作保証**: どのハードウェア構成でも必ず何らかの方法でキャプチャ成功
4. **透明な最適化**: ユーザー操作不要で環境に応じた最適パフォーマンス実現

**調査による重要発見:**
- 統合GPU環境での Windows Graphics Capture API 優位性
- 専用GPU環境でのPCIe転送ボトルネック
- ハードウェア非依存の確実な動作保証の重要性
- GPU種別による最適戦略の大幅な違い

これにより、従来不可能だった大画面ゲーム翻訳を確実に実現し、Baketaの実用性と信頼性を大幅に向上させることができます。