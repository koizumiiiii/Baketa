Phase 5.2 謾ｹ險ら沿蛻・梵蝣ｱ蜻頑嶌縺ｮ繝ｬ繝薙Η繝ｼ繧偵♀鬘倥＞縺励∪縺吶・

## 繝ｬ繝薙Η繝ｼ蟇ｾ雎｡繝峨く繝･繝｡繝ｳ繝・
E:\dev\Baketa\docs\refactoring\PHASE5.2_REVISED_ANALYSIS.md

## 繝ｬ繝薙Η繝ｼ隕ｳ轤ｹ

### 1. **譬ｹ譛ｬ蜴溷屏蛻・梵縺ｮ螯･蠖捺ｧ**
- 蛻晄悄莉ｮ隱ｬ・・afeImageAdapter繧ｭ繝｣繧ｹ繝亥撫鬘鯉ｼ峨′隱､繧翫□縺｣縺溘→縺・≧邨占ｫ悶・豁｣縺励＞縺具ｼ・
- 逵溘・譬ｹ譛ｬ蜴溷屏・・oByteArrayAsync ﾃ・3蝗・+ ArrayPool譛ｪ菴ｿ逕ｨ・峨・險ｺ譁ｭ縺ｯ豁｣縺励＞縺具ｼ・
- InlineImageToWindowsImageAdapter.GetBitmap()縺ｮ.Result菴ｿ逕ｨ縺・91繧ｹ繝ｬ繝・ラ辷・匱縺ｮ蜴溷屏縺ｨ縺・≧蛻・梵縺ｯ螯･蠖薙°・・

### 2. **菫ｮ豁｣譁ｹ驥晢ｼ・rrayPool<byte> + async/await・峨・謚陦鍋噪螯･蠖捺ｧ**
- ArrayPool<byte>蟆主・縺ｫ繧医ｋ蜉ｹ譫懊・譛溷ｾ・壹ｊ縺具ｼ・
- InlineImageToWindowsImageAdapter縺ｮasync蛹厄ｼ・etBitmapAsync・峨・驕ｩ蛻・°・・
- ToPooledByteArrayAsync()諡｡蠑ｵ繝｡繧ｽ繝・ラ險ｭ險医・豁｣縺励＞縺具ｼ・
- ScaleImageWithLanczos縺ｮ菫ｮ豁｣・・NG蝨ｧ邵ｮ繧ｹ繧ｭ繝・・・峨・螯･蠖薙°・・

### 3. **螳溯｣・ｨ育判縺ｮ迴ｾ螳滓ｧ**
- Phase 5.2C: 4-6譎る俣縺ｮ隕狗ｩ阪ｂ繧翫・螯･蠖薙°・・
- Step 1-5縺ｮ螳溯｣・・ｺ上・驕ｩ蛻・°・・
- 蜷・せ繝・ャ繝励・蟾･謨ｰ隕狗ｩ阪ｂ繧翫・迴ｾ螳溽噪縺具ｼ・

### 4. **譛溷ｾ・柑譫懊・隧穂ｾ｡**
- 繝｡繝｢繝ｪ菴ｿ逕ｨ驥・ 2,420MB 竊・50MB莉･荳九→縺・≧逶ｮ讓吶・驕疲・蜿ｯ閭ｽ縺具ｼ・
- 繧ｹ繝ｬ繝・ラ謨ｰ: 191 竊・20莉･荳九→縺・≧逶ｮ讓吶・迴ｾ螳溽噪縺具ｼ・
- OCR繧ｨ繝ｩ繝ｼ・・PaddlePredictor(Detector) run failed"・芽ｧ｣豸医・譬ｹ諡縺ｯ螯･蠖薙°・・

### 5. **隕玖誠縺ｨ縺励※縺・ｋ蝠城｡・*
- 莉悶↓隱ｿ譟ｻ縺吶∋縺崎ｦｳ轤ｹ縺ｯ縺ｪ縺・°・・
- ArrayPool<byte>蟆主・縺ｫ繧医ｋ繝舌げ繧・憶菴懃畑縺ｮ繝ｪ繧ｹ繧ｯ縺ｯ・・
- async/await莨晄眺縺ｫ繧医ｋ遐ｴ螢顔噪螟画峩縺ｮ蠖ｱ髻ｿ遽・峇縺ｯ・・

### 6. **螳溯｣・Μ繧ｹ繧ｯ**
- Phase 5.2C螳溯｣・凾縺ｮ貎懷惠逧・Μ繧ｹ繧ｯ縺ｯ菴輔°・・
- TextRegionDetectorAdapter菫ｮ豁｣縺ｮ豕｢蜿顔ｯ・峇縺ｯ・・
- Mat.FromImageData()縺窟rrayPool縺九ｉ蛟溘ｊ縺歟yte[]繧呈ｭ｣縺励￥謇ｱ縺医ｋ縺具ｼ・

## 隱ｿ譟ｻ繝・・繧ｿ

### 繝｡繝｢繝ｪ繝ｪ繝ｼ繧ｯ螳滓ｸｬ蛟､
- **RAM菴ｿ逕ｨ驥・*: 17 MB 竊・2,420 MB・・42蛟阪・蛻・ｻ･蜀・ｼ・
- **Private Bytes**: 5.72 MB 竊・3,352 MB・・86蛟搾ｼ・
- **繧ｹ繝ｬ繝・ラ謨ｰ**: 9 竊・191・・1蛟搾ｼ・
- **繝上Φ繝峨Ν謨ｰ**: 166 竊・1,734・・0蛟搾ｼ・

### OCR繧ｨ繝ｩ繝ｼ繝ｭ繧ｰ
```
[14:22:24.988][T17] 剥 [ROI_OCR] 鬆伜沺OCR繧ｨ繝ｩ繝ｼ - 蠎ｧ讓・(0,0), 繧ｨ繝ｩ繝ｼ=OCR蜃ｦ逅・ｸｭ縺ｫ繧ｨ繝ｩ繝ｼ縺檎匱逕溘＠縺ｾ縺励◆: PaddlePredictor(Detector) run failed.
[14:22:24.990][T17] 統 [OCR_RESULT] 隱崎ｭ伜ｮ御ｺ・- 蜃ｦ逅・凾髢・ 8012ms
[14:22:24.993][T17] 統 [OCR_RESULT] 讀懷・繝・く繧ｹ繝・ ''
```

### 繝舌ャ繝∫ｿｻ險ｳ邨先棡
- 譛蛻昴・3繝√Ε繝ｳ繧ｯ・・-2・・ 繧ｨ繝ｩ繝ｼ
- 谿九ｊ10繝√Ε繝ｳ繧ｯ・・-12・・ 謌仙粥
- 謌仙粥邇・ 10/13 = 76.9%

## 謚陦鍋噪閭梧勹

### 繧ｳ繝ｼ繝峨・繝ｼ繧ｹ諠・ｱ
- **逕ｻ蜒上し繧､繧ｺ**: 2560x1080 RGB = 邏・MB/逕ｻ蜒・
- **螟画鋤蝗樊焚**: 繧ｹ繧ｱ繝ｼ繝ｪ繝ｳ繧ｰ譛峨ｊ譎・= 3-4蝗槭・ToByteArrayAsync()蜻ｼ縺ｳ蜃ｺ縺・
- **PaddleOCR蛻ｶ邏・*: 螟ｧ逕ｻ髱｢縺ｧ縺ｯ繧ｹ繧ｱ繝ｼ繝ｪ繝ｳ繧ｰ蠢・・
- **譌｢蟄伜ｮ溯｣・*: InlineImageToWindowsImageAdapter・・hase 77.6縺ｧ螳溯｣・ｸ医∩・・

### .NET謚陦薙せ繧ｿ繝・け
- **.NET 8.0**: ArrayPool<T>讓呎ｺ泡PI
- **OpenCvSharp**: Mat.FromImageData()菴ｿ逕ｨ
- **System.Drawing**: Bitmap菴ｿ逕ｨ

謚陦鍋噪縺ｪ隕ｳ轤ｹ縺九ｉ莉･荳九ｒ隧穂ｾ｡縺励※縺上□縺輔＞・・
1. 譬ｹ譛ｬ蜴溷屏蛻・梵縺ｮ豁｣遒ｺ諤ｧ
2. 菫ｮ豁｣譁ｹ驥晢ｼ・rrayPool + async/await・峨・驕ｩ蛻・ｧ
3. 螳溯｣・ｨ育判縺ｮ螳溽樟蜿ｯ閭ｽ諤ｧ
4. 譛溷ｾ・柑譫懊・螯･蠖捺ｧ
5. 貎懷惠逧・Μ繧ｹ繧ｯ縺ｮ迚ｹ螳・
# Phase 5.2 菫ｮ豁｣蛻・梵蝣ｱ蜻頑嶌・域隼險ら沿・・

**菴懈・譌･**: 2025-10-11 20:00
**繧ｹ繝・・繧ｿ繧ｹ**: 譬ｹ譛ｬ蜴溷屏100%迚ｹ螳壼ｮ御ｺ・∽ｿｮ豁｣譁ｹ驥晉ｭ門ｮ壼ｮ御ｺ・

---

## 投 蛻晄悄莉ｮ隱ｬ縺ｮ隱､繧翫→霆碁％菫ｮ豁｣

### 笶・蛻晄悄莉ｮ隱ｬ・・hase 5.2蠖灘・・・
```
SafeImageAdapter菴懈・ 竊・PaddleOcrEngine縺係indowsImage繧ｭ繝｣繧ｹ繝亥､ｱ謨・竊・
InvalidCastException 竊・ObjectDisposedException騾｣骼・竊・繝｡繝｢繝ｪ繝ｪ繝ｼ繧ｯ
```

**Phase 5.2A隱ｿ譟ｻ邨先棡**: 縺薙・莉ｮ隱ｬ縺ｯ**螳悟・縺ｫ隱､繧・*
- PaddleOcrEngine.cs蜀・↓`WindowsImage`縺ｸ縺ｮ萓晏ｭ倥・**繧ｼ繝ｭ**
- OcrExecutionStageStrategy.cs縺ｯ譌｢縺ｫ`IWindowsImage`繧､繝ｳ繧ｿ繝ｼ繝輔ぉ繝ｼ繧ｹ縺ｮ縺ｿ菴ｿ逕ｨ
- InlineImageToWindowsImageAdapter縺梧里縺ｫ螳溯｣・ｸ医∩・・hase 77.6・・

---

## 識 逵溘・譬ｹ譛ｬ蜴溷屏・・00%迚ｹ螳夲ｼ・

### UltraThink Phase 2螳悟・隱ｿ譟ｻ邨先棡

#### **蝠城｡・: 逕ｻ蜒丞､画鋤蜃ｦ逅・〒縺ｮ螟ｧ驥上Γ繝｢繝ｪ蜑ｲ繧雁ｽ薙※**

**蝣ｴ謇**: `PaddleOcrEngine.cs`

##### 1.1 ConvertToMatAsync・・ine 938-1029・・
```csharp
private async Task<Mat> ConvertToMatAsync(IImage image, Rectangle? regionOfInterest, CancellationToken _)
{
    // 櫨 蝠城｡檎ｮ・園: 豈主屓譁ｰ縺励＞byte驟榊・繧貞牡繧雁ｽ薙※
    var imageData = await image.ToByteArrayAsync().ConfigureAwait(false); // Line 950

    var mat = Mat.FromImageData(imageData, ImreadModes.Color);
    // ...
}
```

**蝠城｡檎せ**:
- 2560x1080 RGB逕ｻ蜒・= **邏・MB**縺ｮbyte驟榊・
- `ToByteArrayAsync()`縺・*豈主屓譁ｰ隕丞牡繧雁ｽ薙※**・・rrayPool譛ｪ菴ｿ逕ｨ・・
- Gen2繝偵・繝励↓譏・ｼ縺励※髟ｷ譛滄俣谿句ｭ・

##### 1.2 ScaleImageWithLanczos・・ine 1126-1156・・
```csharp
private async Task<IImage> ScaleImageWithLanczos(IImage originalImage, int targetWidth, int targetHeight,
    CancellationToken cancellationToken)
{
    // 櫨 蝠城｡檎ｮ・園1: 蜈・判蜒上ｒbyte驟榊・縺ｫ螟画鋤
    var imageData = await originalImage.ToByteArrayAsync().ConfigureAwait(false); // Line 1139
    using var originalMat = Mat.FromImageData(imageData, ImreadModes.Color);

    // 櫨 蝠城｡檎ｮ・園2: 繝ｪ繧ｵ繧､繧ｺ蠕後∝・縺ｳbyte驟榊・縺ｫ螟画鋤
    using var resizedMat = new Mat();
    Cv2.Resize(originalMat, resizedMat, new OpenCvSharp.Size(targetWidth, targetHeight),
        interpolation: InterpolationFlags.Lanczos4);

    var resizedImageData = resizedMat.ToBytes(".png"); // Line 1148
    return await __imageFactory.CreateFromBytesAsync(resizedImageData).ConfigureAwait(false);
}
```

**蝠城｡檎せ**:
- 繧ｹ繧ｱ繝ｼ繝ｪ繝ｳ繧ｰ蜃ｦ逅・〒**2蝗・*縺ｮbyte驟榊・蜑ｲ繧雁ｽ薙※・亥・逕ｻ蜒・MB + 繝ｪ繧ｵ繧､繧ｺ蠕・MB・・
- PNG蝨ｧ邵ｮ蜃ｦ逅・・繧ｪ繝ｼ繝舌・繝倥ャ繝・
- 譁ｰ縺励＞IImage繧､繝ｳ繧ｹ繧ｿ繝ｳ繧ｹ菴懈・

##### 1.3 ConvertToMatWithScalingAsync・・ine 1038-1116・・
```csharp
private async Task<(Mat mat, double scaleFactor)> ConvertToMatWithScalingAsync(
    IImage image, Rectangle? regionOfInterest, CancellationToken cancellationToken)
{
    // Step 3: 繧ｹ繧ｱ繝ｼ繝ｪ繝ｳ繧ｰ螳溯｡・
    if (Math.Abs(scaleFactor - 1.0) >= 0.001)
    {
        processImage = await ScaleImageWithLanczos(image, newWidth, newHeight, cancellationToken); // Line 1063
    }

    // Step 5: 櫨 蝠城｡檎ｮ・園: 繧ｹ繧ｱ繝ｼ繝ｪ繝ｳ繧ｰ貂医∩逕ｻ蜒上ｒ蜀阪・Mat縺ｫ螟画鋤
    var mat = await ConvertToMatAsync(processImage, adjustedRoi, cancellationToken); // Line 1107

    // Step 6: 繧ｹ繧ｱ繝ｼ繝ｪ繝ｳ繧ｰ逕ｻ蜒上・Dispose
    if (processImage != image)
    {
        processImage.Dispose(); // Line 1112
    }

    return (mat, scaleFactor);
}
```

**蝠城｡後・騾｣骼・*:
```
蜈・判蜒・8MB)
   竊・ScaleImageWithLanczos蜻ｼ縺ｳ蜃ｺ縺・
   笏懌楳 ToByteArrayAsync() 竊・8MB蜑ｲ繧雁ｽ薙※
   笏懌楳 Mat.FromImageData() 竊・Mat菴懈・
   笏懌楳 Cv2.Resize() 竊・繝ｪ繧ｵ繧､繧ｺMat菴懈・
   笏披楳 ToBytes(".png") 竊・8MB蜑ｲ繧雁ｽ薙※・亥悸邵ｮ蠕鯉ｼ・
   竊・ConvertToMatAsync蜻ｼ縺ｳ蜃ｺ縺・
   笏披楳 ToByteArrayAsync() 竊・蜀阪・8MB蜑ｲ繧雁ｽ薙※
   竊・
蜷郁ｨ・ 24MB縺ｮ繝｡繝｢繝ｪ蜑ｲ繧雁ｽ薙※・・蝗槭・OCR螳溯｡後≠縺溘ｊ・・
```

#### **蝠城｡・: InlineImageToWindowsImageAdapter縺ｮ蜷梧悄逧・ヶ繝ｭ繝・く繝ｳ繧ｰ**

**蝣ｴ謇**: `OcrExecutionStageStrategy.cs:646-673`・・nlineImageToWindowsImageAdapter.GetBitmap()・・

```csharp
public Bitmap GetBitmap()
{
    ObjectDisposedException.ThrowIf(_disposed, this);

    if (_cachedBitmap != null)
    {
        return _cachedBitmap;
    }

    try
    {
        _logger.LogDebug("売 [PHASE77.6] IImage 竊・Bitmap 螟画鋤髢句ｧ・);

        // 櫨 閾ｴ蜻ｽ逧・撫鬘・ async繝｡繧ｽ繝・ラ繧・Result縺ｧ蜷梧悄逧・↓繝悶Ο繝・け
        var imageBytes = _underlyingImage.ToByteArrayAsync().Result; // Line 659
        using var memoryStream = new MemoryStream(imageBytes);
        _cachedBitmap = new Bitmap(memoryStream);

        return _cachedBitmap;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "笶・[PHASE77.6] IImage 竊・Bitmap 螟画鋤螟ｱ謨・);
        throw;
    }
}
```

**蝠城｡檎せ**:
1. **繝・ャ繝峨Ο繝・け繝ｪ繧ｹ繧ｯ**: async/await繧・Result縺ｧ蜷梧悄蠕・ｩ・
2. **繧ｹ繝ｬ繝・ラ繝励・繝ｫ縺ｮ譫ｯ貂・*:
   - 螳滓ｸｬ: 9繧ｹ繝ｬ繝・ラ 竊・**191繧ｹ繝ｬ繝・ラ**・・1蛟咲・逋ｺ・・
   - 蜷・Result縺後せ繝ｬ繝・ラ繧偵ヶ繝ｭ繝・け
   - 譁ｰ縺励＞繧ｹ繝ｬ繝・ラ縺梧ｬ｡縲・↓菴懈・縺輔ｌ繧・
3. **MemoryStream蜊ｳ蠎ｧ遐ｴ譽・*: Bitmap菴懈・蠕後☆縺舌↓using遐ｴ譽・＆繧後ｋ縺後。itmap縺悟・驛ｨ蜿ら・繧剃ｿ晄戟縺励※縺・ｋ蜿ｯ閭ｽ諤ｧ

#### **蝠城｡・: 繧ｨ繝ｩ繝ｼ繝上Φ繝峨Μ繝ｳ繧ｰ縺ｧ縺ｮ繝ｪ繝医Λ繧､繝ｫ繝ｼ繝・*

**蝣ｴ謇**: `OcrExecutionStageStrategy.cs:314-319`

```csharp
catch (Exception ex)
{
    _logger.LogWarning(ex, "識 UltraThink: 鬆伜沺({X},{Y},{Width},{Height})縺ｮOCR蜃ｦ逅・〒繧ｨ繝ｩ繝ｼ - 繧ｹ繧ｭ繝・・",
        region.X, region.Y, region.Width, region.Height);
    DebugLogUtility.WriteLog($"剥 [ROI_OCR] 鬆伜沺OCR繧ｨ繝ｩ繝ｼ - 蠎ｧ讓・({region.X},{region.Y}), 繧ｨ繝ｩ繝ｼ={ex.Message}");
}
```

**蝠城｡檎せ**:
- 繧ｨ繝ｩ繝ｼ逋ｺ逕滓凾縲∝腰縺ｫ繧ｹ繧ｭ繝・・縺吶ｋ縺縺代〒谺｡縺ｮ鬆伜沺縺ｸ
- 隍・焚鬆伜沺縺ｧ蜷後§繧ｨ繝ｩ繝ｼ縺檎ｹｰ繧願ｿ斐＠逋ｺ逕・
- 蜷・お繝ｩ繝ｼ縺斐→縺ｫ24MB縺ｮ繝｡繝｢繝ｪ蜑ｲ繧雁ｽ薙※
- 繧ｨ繝ｩ繝ｼ繝ｭ繧ｰ縺ｫ縺ｯ`PaddlePredictor(Detector) run failed`・・遘偵ち繧､繝繧｢繧ｦ繝茨ｼ・

---

## 溌 繝｡繝｢繝ｪ繝ｪ繝ｼ繧ｯ逋ｺ逕溘Γ繧ｫ繝九ぜ繝

### 螳滓ｸｬ繝・・繧ｿ縺ｫ蝓ｺ縺･縺剰ｧ｣譫・

| 邨碁℃譎る俣 | RAM (MB) | Private Bytes (MB) | 繧ｹ繝ｬ繝・ラ謨ｰ | 繝上Φ繝峨Ν謨ｰ | 迥ｶ諷・|
|---------|---------|-------------------|----------|----------|------|
| 0遘・| 17.05 | 5.72 | 9 | 166 | 襍ｷ蜍慕峩蠕・|
| 11遘・| 112.05 | 43.94 | 30 | 787 | 蛻晏屓OCR螳溯｡・|
| 36遘・| 1,821.45 | 2,109.07 | 156 | 1,663 | 繝ｪ繝医Λ繧､騾｣骼夜幕蟋・|
| 56遘・| 2,420.52 | 3,352.64 | 191 | 1,699 | 繝｡繝｢繝ｪ辷・匱 |

### 逋ｺ逕溘す繝ｼ繧ｱ繝ｳ繧ｹ

```
1. 繝ｦ繝ｼ繧ｶ繝ｼ縺郡tart繝懊ち繝ｳ繧呈款荳・
   竊・
2. 繧ｭ繝｣繝励メ繝｣螳溯｡鯉ｼ・560x1080逕ｻ蜒・= 8MB・・
   竊・
3. TextRegionDetector螳溯｡鯉ｼ・OI讀懷・・・
   笏懌楳 InlineImageToWindowsImageAdapter菴懈・
   笏懌楳 GetBitmap()蜻ｼ縺ｳ蜃ｺ縺暦ｼ・Result縺ｧ繝悶Ο繝・け・・
   笏披楳 ToByteArrayAsync() 竊・8MB蜑ｲ繧雁ｽ薙※ #1
   竊・
4. PaddleOcrEngine.RecognizeAsync螳溯｡鯉ｼ郁､・焚鬆伜沺・・
   笏懌楳 ConvertToMatWithScalingAsync
   笏・ 笏懌楳 ScaleImageWithLanczos
   笏・ 笏・ 笏懌楳 ToByteArrayAsync() 竊・8MB蜑ｲ繧雁ｽ薙※ #2
   笏・ 笏・ 笏披楳 ToBytes(".png") 竊・8MB蜑ｲ繧雁ｽ薙※ #3
   笏・ 笏披楳 ConvertToMatAsync
   笏・    笏披楳 ToByteArrayAsync() 竊・8MB蜑ｲ繧雁ｽ薙※ #4
   笏懌楳 PaddleOCR螳溯｡・竊・"PaddlePredictor(Detector) run failed"
   笏披楳 繧ｨ繝ｩ繝ｼ繝上Φ繝峨Μ繝ｳ繧ｰ: 谺｡縺ｮ鬆伜沺縺ｸ繧ｹ繧ｭ繝・・
   竊・
5. 隍・焚鬆伜沺縺ｧ繧ｹ繝・ャ繝・縺檎ｹｰ繧願ｿ斐＆繧後ｋ
   笏懌楳 蜷・伜沺縺ｧ24-32MB蜑ｲ繧雁ｽ薙※
   笏懌楳 繧ｨ繝ｩ繝ｼ繝ｪ繝医Λ繧､縺ｧ縺輔ｉ縺ｫ蠅怜刈
   笏披楳 Gen2繝偵・繝励↓譏・ｼ縺励※髟ｷ譛滓ｻ樒蕗
   竊・
6. 繧ｹ繝ｬ繝・ラ繝励・繝ｫ譫ｯ貂・
   笏懌楳 .Result繝悶Ο繝・け縺ｫ繧医ｊ繧ｹ繝ｬ繝・ラ蠅怜刈
   笏披楳 9 竊・191繧ｹ繝ｬ繝・ラ・・1蛟搾ｼ・
   竊・
7. 繝上Φ繝峨Ν繝ｪ繝ｼ繧ｯ
   笏懌楳 蜷・判蜒丞､画鋤縺ｧ繝上Φ繝峨Ν菴懈・
   笏披楳 166 竊・1,699繝上Φ繝峨Ν・・0蛟搾ｼ・
   竊・
8. 邨先棡: 17MB 竊・2,420MB・・42蛟搾ｼ永n 1蛻・
```

---

## 庁 菫ｮ豁｣譁ｹ驥晢ｼ・ltraThink Phase 3-5・・

### 蜆ｪ蜈亥ｺｦP0: ArrayPool<byte>蟆主・

#### 菫ｮ豁｣蟇ｾ雎｡1: ConvertToMatAsync

**菫ｮ豁｣蜑・*:
```csharp
var imageData = await image.ToByteArrayAsync().ConfigureAwait(false);
var mat = Mat.FromImageData(imageData, ImreadModes.Color);
```

**菫ｮ豁｣蠕・*:
```csharp
// ArrayPool繧剃ｽｿ逕ｨ縺励◆蜉ｹ邇・噪縺ｪbyte驟榊・邂｡逅・
byte[]? pooledArray = null;
try
{
    pooledArray = await image.ToPooledByteArrayAsync().ConfigureAwait(false);
    var mat = Mat.FromImageData(pooledArray, ImreadModes.Color);
    return mat;
}
finally
{
    if (pooledArray != null)
    {
        ArrayPool<byte>.Shared.Return(pooledArray);
    }
}
```

#### 菫ｮ豁｣蟇ｾ雎｡2: ScaleImageWithLanczos

**菫ｮ豁｣蜑・*:
```csharp
var imageData = await originalImage.ToByteArrayAsync().ConfigureAwait(false);
using var originalMat = Mat.FromImageData(imageData, ImreadModes.Color);
```

**菫ｮ豁｣蠕・*:
```csharp
byte[]? pooledArray = null;
try
{
    pooledArray = await originalImage.ToPooledByteArrayAsync().ConfigureAwait(false);
    using var originalMat = Mat.FromImageData(pooledArray, ImreadModes.Color);

    // Lanczos繝ｪ繧ｵ繝ｳ繝励Μ繝ｳ繧ｰ
    using var resizedMat = new Mat();
    Cv2.Resize(originalMat, resizedMat, new OpenCvSharp.Size(targetWidth, targetHeight),
        interpolation: InterpolationFlags.Lanczos4);

    // Mat縺九ｉIImage縺ｫ逶ｴ謗･螟画鋤・・NG蝨ｧ邵ｮ繧偵せ繧ｭ繝・・・・
    return await __imageFactory.CreateFromMatAsync(resizedMat).ConfigureAwait(false);
}
finally
{
    if (pooledArray != null)
    {
        ArrayPool<byte>.Shared.Return(pooledArray);
    }
}
```

### 蜆ｪ蜈亥ｺｦP0: InlineImageToWindowsImageAdapter縺ｮasync蛹・

**菫ｮ豁｣蜑・*:
```csharp
public Bitmap GetBitmap()
{
    var imageBytes = _underlyingImage.ToByteArrayAsync().Result; // 竊・蜷梧悄繝悶Ο繝・け
    using var memoryStream = new MemoryStream(imageBytes);
    _cachedBitmap = new Bitmap(memoryStream);
    return _cachedBitmap;
}
```

**菫ｮ豁｣蠕・*:
```csharp
public async Task<Bitmap> GetBitmapAsync(CancellationToken cancellationToken = default)
{
    ObjectDisposedException.ThrowIf(_disposed, this);

    if (_cachedBitmap != null)
    {
        return _cachedBitmap;
    }

    byte[]? pooledArray = null;
    try
    {
        _logger.LogDebug("売 [PHASE5.2] IImage 竊・Bitmap 螟画鋤髢句ｧ具ｼ・sync + ArrayPool・・);

        pooledArray = await _underlyingImage.ToPooledByteArrayAsync(cancellationToken).ConfigureAwait(false);
        using var memoryStream = new MemoryStream(pooledArray, writable: false);
        _cachedBitmap = new Bitmap(memoryStream);

        _logger.LogDebug("笨・[PHASE5.2] Bitmap 螟画鋤謌仙粥");
        return _cachedBitmap;
    }
    catch (Exception ex)
    {
        _logger.LogError(ex, "笶・[PHASE5.2] IImage 竊・Bitmap 螟画鋤螟ｱ謨・);
        throw new InvalidOperationException($"Failed to convert IImage to Bitmap: {ex.Message}", ex);
    }
    finally
    {
        if (pooledArray != null)
        {
            ArrayPool<byte>.Shared.Return(pooledArray);
        }
    }
}
```

**騾｣骼紋ｿｮ豁｣**: TextRegionDetectorAdapter繧ＡGetBitmapAsync()`繧貞他縺ｶ繧医≧縺ｫ螟画峩

### 蜆ｪ蜈亥ｺｦP1: IImage諡｡蠑ｵ繝｡繧ｽ繝・ラ霑ｽ蜉

**譁ｰ隕丈ｽ懈・**: `Baketa.Core/Services/Imaging/IImageExtensions.cs`

```csharp
public static class IImageExtensions
{
    /// <summary>
    /// ArrayPool<byte>繧剃ｽｿ逕ｨ縺励◆蜉ｹ邇・噪縺ｪbyte驟榊・蜿門ｾ・
    /// </summary>
    public static async Task<byte[]> ToPooledByteArrayAsync(
        this IImage image,
        CancellationToken cancellationToken = default)
    {
        var imageData = await image.ToByteArrayAsync(cancellationToken).ConfigureAwait(false);

        // ArrayPool縺九ｉ繝ｬ繝ｳ繧ｿ繝ｫ
        var pooledArray = ArrayPool<byte>.Shared.Rent(imageData.Length);
        Array.Copy(imageData, pooledArray, imageData.Length);

        return pooledArray;
    }
}
```

### 蜆ｪ蜈亥ｺｦP1: IImageFactory諡｡蠑ｵ

**霑ｽ蜉繝｡繧ｽ繝・ラ**: `CreateFromMatAsync`

```csharp
public interface IImageFactory
{
    // 譌｢蟄倥Γ繧ｽ繝・ラ
    Task<IImage> CreateFromBytesAsync(byte[] imageBytes);

    // ・ 譁ｰ隕剰ｿｽ蜉: Mat逶ｴ謗･螟画鋤・・NG蝨ｧ邵ｮ繧ｹ繧ｭ繝・・・・
    Task<IImage> CreateFromMatAsync(Mat mat);
}
```

---

## 搭 螳溯｣・ｨ育判

### Phase 5.2C: ArrayPool<byte>螳溯｣・ｼ・-6譎る俣・・

#### Step 1: IImageExtensions菴懈・・・0蛻・ｼ・
- [ ] `ToPooledByteArrayAsync()`諡｡蠑ｵ繝｡繧ｽ繝・ラ螳溯｣・
- [ ] 蜊倅ｽ薙ユ繧ｹ繝井ｽ懈・

#### Step 2: PaddleOcrEngine菫ｮ豁｣・・譎る俣・・
- [ ] `ConvertToMatAsync()` ArrayPool蟇ｾ蠢・
- [ ] `ScaleImageWithLanczos()` ArrayPool蟇ｾ蠢・
- [ ] `ConvertToMatWithScalingAsync()` 菫ｮ豁｣
- [ ] 繝｡繝｢繝ｪ繝ｪ繝ｼ繧ｯ髦ｲ豁｢縺ｮfinally蜿･霑ｽ蜉

#### Step 3: InlineImageToWindowsImageAdapter菫ｮ豁｣・・.5譎る俣・・
- [ ] `GetBitmapAsync()` async蛹・
- [ ] ArrayPool蟇ｾ蠢・
- [ ] OcrExecutionStageStrategy蛛ｴ縺ｮ蜻ｼ縺ｳ蜃ｺ縺嶺ｿｮ豁｣

#### Step 4: TextRegionDetectorAdapter菫ｮ豁｣・・譎る俣・・
- [ ] `GetBitmapAsync()`蜻ｼ縺ｳ蜃ｺ縺励↓螟画峩
- [ ] async/await莨晄眺

#### Step 5: IImageFactory諡｡蠑ｵ・・譎る俣・・
- [ ] `CreateFromMatAsync()` 螳溯｣・
- [ ] ScaleImageWithLanczos縺ｧ菴ｿ逕ｨ

### Phase 5.2D: 邨ｱ蜷医ユ繧ｹ繝茨ｼ・-3譎る俣・・

#### Test 1: 繝｡繝｢繝ｪ繝ｪ繝ｼ繧ｯ隗｣豸育｢ｺ隱・
- [ ] 繧｢繝励Μ襍ｷ蜍補・鄙ｻ險ｳ螳溯｡娯・繝ｪ繧ｽ繝ｼ繧ｹ逶｣隕・
- [ ] 譛溷ｾ・ RAM菴ｿ逕ｨ驥・00MB莉･荳狗ｶｭ謖・

#### Test 2: 繧ｹ繝ｬ繝・ラ謨ｰ螳牙ｮ夂｢ｺ隱・
- [ ] 譛溷ｾ・ 繧ｹ繝ｬ繝・ラ謨ｰ20莉･荳狗ｶｭ謖・

#### Test 3: 繝上Φ繝峨Ν謨ｰ螳牙ｮ夂｢ｺ隱・
- [ ] 譛溷ｾ・ 繝上Φ繝峨Ν謨ｰ500莉･荳狗ｶｭ謖・

#### Test 4: OCR謌仙粥邇・｢ｺ隱・
- [ ] 譛溷ｾ・ "PaddlePredictor(Detector) run failed"隗｣豸・
- [ ] 譛溷ｾ・ OCR謌仙粥邇・00%

#### Test 5: 鄙ｻ險ｳ謌仙粥邇・｢ｺ隱・
- [ ] 譛溷ｾ・ 繝舌ャ繝∫ｿｻ險ｳ繧ｨ繝ｩ繝ｼ隗｣豸・
- [ ] 譛溷ｾ・ 鄙ｻ險ｳ謌仙粥邇・00%

---

## 笨・譛溷ｾ・柑譫・

| 鬆・岼 | 菫ｮ豁｣蜑・| 菫ｮ豁｣蠕鯉ｼ域悄蠕・ｼ・|
|------|--------|----------------|
| **繝｡繝｢繝ｪ菴ｿ逕ｨ驥・* | 17MB 竊・2,420MB・・42蛟搾ｼ・| 17MB 竊・50MB莉･荳具ｼ域ｭ｣蟶ｸ遽・峇・・|
| **1蝗槭・OCR蜑ｲ繧雁ｽ薙※** | 24-32MB | 0MB・・rrayPool蜀榊茜逕ｨ・・|
| **繧ｹ繝ｬ繝・ラ謨ｰ** | 9 竊・191・・1蛟搾ｼ・| 9 竊・20莉･荳具ｼ亥ｮ牙ｮ夲ｼ・|
| **繝上Φ繝峨Ν謨ｰ** | 166 竊・1,699・・0蛟搾ｼ・| 166 竊・500莉･荳具ｼ域ｭ｣蟶ｸ・・|
| **OCR繧ｨ繝ｩ繝ｼ** | "PaddlePredictor run failed" | **螳悟・隗｣豸・* |
| **鄙ｻ險ｳ謌仙粥邇・* | 10/13・・6.9%・・| **100%** |
| **GC蝨ｧ蜉・* | Gen2鬆ｻ逋ｺ | Gen0/1縺ｧ螳檎ｵ・|

---

## 識 謚陦鍋噪螯･蠖捺ｧ隧穂ｾ｡

### ArrayPool<byte>縺ｮ繝吶せ繝医・繝ｩ繧ｯ繝・ぅ繧ｹ驕ｩ蜷域ｧ
- 笨・.NET蜈ｬ蠑乗耳螂ｨ繝代ち繝ｼ繝ｳ
- 笨・Gen2繝偵・繝怜悸蜉帛炎貂・
- 笨・螟ｧ隕乗ｨ｡byte驟榊・縺ｮ蜉ｹ邇・噪邂｡逅・
- 笨・繧ｹ繝ｫ繝ｼ繝励ャ繝亥髄荳・

### async/await豁｣縺励＞菴ｿ逕ｨ
- 笨・`.Result`繧｢繝ｳ繝√ヱ繧ｿ繝ｼ繝ｳ謗帝勁
- 笨・繝・ャ繝峨Ο繝・け繝ｪ繧ｹ繧ｯ隗｣豸・
- 笨・繧ｹ繝ｬ繝・ラ繝励・繝ｫ譫ｯ貂・亟豁｢
- 笨・Clean Architecture貅匁侠

### 繝代ヵ繧ｩ繝ｼ繝槭Φ繧ｹ蠖ｱ髻ｿ
- 笨・ArrayPool: 繧ｪ繝ｼ繝舌・繝倥ャ繝画･ｵ蟆・
- 笨・async/await: 豁｣縺励￥菴ｿ逕ｨ縺吶ｌ縺ｰ繧ｳ繧ｹ繝育┌隕門庄閭ｽ
- 笨・繝｡繝｢繝ｪ蜉ｹ邇・ 螟ｧ蟷・隼蝟・

---

## 答 髢｢騾｣繝峨く繝･繝｡繝ｳ繝・

- `E:\dev\Baketa\docs\refactoring\PHASE5_MEMORY_LEAK_INVESTIGATION.md` - 蛻晄悄隱ｿ譟ｻ蝣ｱ蜻・
- `E:\dev\Baketa\docs\refactoring\PHASE5.2_IMPLEMENTATION_PLAN.md` - 蛻晄悄螳溯｣・ｨ育判・井ｻｮ隱ｬ隱､繧奇ｼ・
- `E:\dev\Baketa\Baketa.Infrastructure\OCR\PaddleOCR\Engine\PaddleOcrEngine.cs` - 菫ｮ豁｣蟇ｾ雎｡繝輔ぃ繧､繝ｫ
- `E:\dev\Baketa\Baketa.Infrastructure\Processing\Strategies\OcrExecutionStageStrategy.cs` - 菫ｮ豁｣蟇ｾ雎｡繝輔ぃ繧､繝ｫ

---

**菴懈・閠・*: Claude Code (UltraThink譁ｹ豕戊ｫ悶↓繧医ｋ譬ｹ譛ｬ蜴溷屏100%迚ｹ螳・
**繧ｹ繝・・繧ｿ繧ｹ**: 菫ｮ豁｣譁ｹ驥晉｢ｺ螳壹∝ｮ溯｣・ｺ門ｙ螳御ｺ・
