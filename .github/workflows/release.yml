name: Release Build and Publish

on:
  push:
    tags:
      - 'v*.*.*'
      - 'beta-*'

env:
  DOTNET_VERSION: '8.0.x'
  PYTHON_VERSION: '3.10'
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true

jobs:
  # Job 1: Build .NET Application and Create Release
  build-and-release:
    name: Build and Release
    runs-on: windows-latest

    permissions:
      contents: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v6
      with:
        fetch-depth: 0

    - name: Extract version info
      id: version
      run: |
        $tag = "${{ github.ref_name }}"
        $version = $tag -replace '^v', ''
        $isPrerelease = $tag -match '^(alpha|beta|v.*-(alpha|beta|rc))'

        echo "version=$version" >> $env:GITHUB_OUTPUT
        echo "is-prerelease=$isPrerelease" >> $env:GITHUB_OUTPUT

        echo "## Release Information" >> $env:GITHUB_STEP_SUMMARY
        echo "- Tag: $tag" >> $env:GITHUB_STEP_SUMMARY
        echo "- Version: $version" >> $env:GITHUB_STEP_SUMMARY
        echo "- Pre-release: $isPrerelease" >> $env:GITHUB_STEP_SUMMARY

    - name: Setup .NET
      uses: actions/setup-dotnet@v5
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Install Windows SDK 10.0.19041.0 with UWP components
      run: |
        # CsWinRT requires UAP Platform.xml which is part of Windows SDK UWP components
        # Download and install Windows SDK 10.0.19041.0 with UAP components
        $sdkUrl = "https://go.microsoft.com/fwlink/?linkid=2120843"
        $installerPath = "$env:TEMP\winsdksetup.exe"

        Write-Host "Downloading Windows SDK 10.0.19041.0..."
        Invoke-WebRequest -Uri $sdkUrl -OutFile $installerPath -UseBasicParsing

        Write-Host "Installing Windows SDK with UWP components..."
        # Install SDK features needed for CsWinRT (Desktop C++ ARM64 includes UAP)
        Start-Process -FilePath $installerPath -ArgumentList "/features OptionId.UWPCpp /q /norestart" -Wait -NoNewWindow

        # Verify installation
        $platformXml = "C:\Program Files (x86)\Windows Kits\10\Platforms\UAP\10.0.19041.0\Platform.xml"
        if (Test-Path $platformXml) {
          Write-Host "‚úÖ Windows SDK UAP components installed successfully"
        } else {
          Write-Host "‚ö†Ô∏è Platform.xml not found, listing available platforms..."
          Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\Platforms\" -Recurse -ErrorAction SilentlyContinue | Select-Object FullName
        }
      shell: pwsh

    - name: Setup Python for PyInstaller
      uses: actions/setup-python@v6
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Build Translation Server with PyInstaller
      run: |
        Write-Host "üì¶ Building BaketaTranslationServer with PyInstaller..."

        cd grpc_server

        # Install dependencies
        pip install --upgrade pip
        pip install -r requirements.txt
        pip install pyinstaller

        # Build with PyInstaller
        pyinstaller BaketaTranslationServer.spec --clean

        # Verify build
        $exePath = "dist\BaketaTranslationServer\BaketaTranslationServer.exe"
        if (Test-Path $exePath) {
          Write-Host "‚úÖ BaketaTranslationServer.exe built successfully"
          $size = [math]::Round((Get-Item $exePath).Length / 1MB, 2)
          Write-Host "   Size: $size MB"
        } else {
          Write-Host "‚ùå BaketaTranslationServer.exe not found!"
          exit 1
        }

        cd ..
      shell: pwsh

    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2

    - name: Build Native DLL (BaketaCaptureNative)
      run: |
        Write-Host "üî® Building BaketaCaptureNative.dll (C++/WinRT)..."
        msbuild BaketaCaptureNative\BaketaCaptureNative.vcxproj /p:Configuration=Release /p:Platform=x64 /verbosity:minimal

        # Verify DLL was built
        $dllPath = "BaketaCaptureNative\bin\Release\BaketaCaptureNative.dll"
        if (Test-Path $dllPath) {
          Write-Host "‚úÖ BaketaCaptureNative.dll built successfully"
          $size = [math]::Round((Get-Item $dllPath).Length / 1KB, 2)
          Write-Host "   Size: $size KB"
        } else {
          Write-Host "‚ùå BaketaCaptureNative.dll not found!"
          exit 1
        }
      shell: pwsh

    - name: Publish UI application
      run: |
        dotnet publish Baketa.UI/Baketa.UI.csproj `
          --configuration Release `
          --runtime win-x64 `
          --self-contained true `
          -p:IS_DISTRIBUTION=true `
          --output ./publish/Baketa-${{ steps.version.outputs.version }} `
          --verbosity minimal

    - name: Copy Native DLL to publish directory
      run: |
        $version = "${{ steps.version.outputs.version }}"
        $publishDir = "./publish/Baketa-$version"
        $dllSource = "BaketaCaptureNative\bin\Release\BaketaCaptureNative.dll"

        Write-Host "üì¶ Copying BaketaCaptureNative.dll to publish directory..."
        Copy-Item $dllSource $publishDir -Force

        if (Test-Path "$publishDir\BaketaCaptureNative.dll") {
          Write-Host "‚úÖ Native DLL copied successfully"
        } else {
          Write-Host "‚ùå Failed to copy native DLL!"
          exit 1
        }
      shell: pwsh

    - name: Copy Translation Server to publish directory
      run: |
        $version = "${{ steps.version.outputs.version }}"
        $publishDir = "./publish/Baketa-$version"
        $serverSource = "grpc_server\dist\BaketaTranslationServer"
        $serverDest = "$publishDir\grpc_server\BaketaTranslationServer"

        Write-Host "üì¶ Copying BaketaTranslationServer to publish directory..."

        # Create destination directory
        New-Item -ItemType Directory -Path $serverDest -Force | Out-Null

        # Copy entire PyInstaller output
        Copy-Item "$serverSource\*" $serverDest -Recurse -Force

        if (Test-Path "$serverDest\BaketaTranslationServer.exe") {
          Write-Host "‚úÖ Translation Server copied successfully"
          $totalSize = (Get-ChildItem $serverDest -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB
          Write-Host "   Total size: $([math]::Round($totalSize, 2)) MB"
        } else {
          Write-Host "‚ùå Failed to copy Translation Server!"
          exit 1
        }
      shell: pwsh

    - name: Optimize package size
      run: |
        $version = "${{ steps.version.outputs.version }}"
        $publishDir = "./publish/Baketa-$version"

        Write-Host "üîß Optimizing package size..."

        # Remove unnecessary language folders (keep ja, en only)
        $unnecessaryLangs = @('cs', 'de', 'es', 'fr', 'it', 'ko', 'pl', 'pt-BR', 'ru', 'tr', 'zh-Hans', 'zh-Hant')
        $removedCount = 0
        $removedSize = 0
        foreach ($lang in $unnecessaryLangs) {
          $langPath = Join-Path $publishDir $lang
          if (Test-Path $langPath) {
            $folderSize = (Get-ChildItem -LiteralPath $langPath -Recurse -File | Measure-Object -Property Length -Sum).Sum
            $removedSize += $folderSize
            Remove-Item -LiteralPath $langPath -Recurse -Force
            $removedCount++
          }
        }
        Write-Host "  Removed $removedCount language folders ($([math]::Round($removedSize/1MB, 2)) MB freed)"

        # Remove dev config files
        $devConfigFiles = @('appsettings.Development.json', 'appsettings.AlphaTest.json', 'appsettings.Local.json')
        foreach ($file in $devConfigFiles) {
          $filePath = Join-Path $publishDir $file
          if (Test-Path $filePath) {
            Remove-Item -LiteralPath $filePath -Force
            Write-Host "  Removed: $file"
          }
        }

        # Remove PDB files
        $pdbFiles = Get-ChildItem -Path $publishDir -Filter "*.pdb" -Recurse
        $pdbCount = 0
        $pdbSize = 0
        foreach ($pdb in $pdbFiles) {
          $pdbSize += $pdb.Length
          Remove-Item -LiteralPath $pdb.FullName -Force
          $pdbCount++
        }
        if ($pdbCount -gt 0) {
          Write-Host "  Removed: $pdbCount PDB files ($([math]::Round($pdbSize/1MB, 2)) MB freed)"
        }

        # Remove XML doc files (except config files)
        $xmlDocFiles = Get-ChildItem -Path $publishDir -Filter "*.xml" -Recurse | Where-Object { $_.Name -notmatch 'appsettings|config' }
        $xmlCount = 0
        $xmlSize = 0
        foreach ($xml in $xmlDocFiles) {
          $xmlSize += $xml.Length
          Remove-Item -LiteralPath $xml.FullName -Force
          $xmlCount++
        }
        if ($xmlCount -gt 0) {
          Write-Host "  Removed: $xmlCount XML doc files ($([math]::Round($xmlSize/1MB, 2)) MB freed)"
        }

        # Display final size
        $finalSize = (Get-ChildItem $publishDir -Recurse -File | Measure-Object -Property Length -Sum).Sum / 1MB
        Write-Host "‚úÖ Optimization complete. Final size: $([math]::Round($finalSize, 2)) MB"
      shell: pwsh

    - name: Create .NET package
      run: |
        $version = "${{ steps.version.outputs.version }}"
        $publishDir = "./publish/Baketa-$version"
        $zipName = "Baketa-$version.zip"

        # Copy additional files
        Copy-Item "README.md" "$publishDir/" -ErrorAction SilentlyContinue
        Copy-Item "LICENSE" "$publishDir/" -ErrorAction SilentlyContinue

        # Create zip package
        Compress-Archive -Path "$publishDir/*" -DestinationPath "./publish/$zipName" -Force

        $size = [math]::Round((Get-Item "./publish/$zipName").Length / 1MB, 2)
        echo "## .NET Package" >> $env:GITHUB_STEP_SUMMARY
        echo "- Package: $zipName" >> $env:GITHUB_STEP_SUMMARY
        echo "- Size: $size MB" >> $env:GITHUB_STEP_SUMMARY

    # [Issue #249] Generate AppCast for auto-update
    - name: Install NetSparkle AppCast Generator
      run: |
        Write-Host "üì¶ Installing NetSparkle AppCast Generator..."
        dotnet tool install --global NetSparkleUpdater.Tools.AppCastGenerator
        Write-Host "‚úÖ AppCast Generator installed"
      shell: pwsh

    - name: Generate AppCast with Ed25519 signature
      env:
        SPARKLE_PRIVATE_KEY: ${{ secrets.NETSPARKLE_ED25519_PRIVATE_KEY }}
      run: |
        $version = "${{ steps.version.outputs.version }}"
        $zipFile = "./publish/Baketa-$version.zip"
        $downloadUrl = "https://github.com/koizumiiiii/Baketa/releases/download/v$version"

        Write-Host "üîê Generating AppCast with Ed25519 signature..."

        # Check if private key is set
        if ([string]::IsNullOrWhiteSpace($env:SPARKLE_PRIVATE_KEY)) {
          Write-Host "‚ö†Ô∏è NETSPARKLE_ED25519_PRIVATE_KEY secret not set - skipping AppCast generation"
          Write-Host "   To enable auto-update, add the secret to repository settings"
          exit 0
        }

        # Create a dedicated directory for AppCast generation (zip only)
        $appcastDir = "./appcast-build"
        New-Item -ItemType Directory -Path $appcastDir -Force | Out-Null
        Copy-Item $zipFile $appcastDir -Force

        # Generate appcast.json
        # Note: The tool uses SPARKLE_PRIVATE_KEY environment variable automatically
        netsparkle-generate-appcast `
          --binaries $appcastDir `
          --appcast-output-directory ./publish `
          --base-url $downloadUrl `
          --output-type json `
          --os windows `
          --ext zip `
          --file-extract-version

        # Verify generation
        if (Test-Path "./publish/appcast.json") {
          Write-Host "‚úÖ appcast.json generated successfully"
          Get-Content "./publish/appcast.json" | Write-Host
          echo "## AppCast" >> $env:GITHUB_STEP_SUMMARY
          echo "- appcast.json generated with Ed25519 signature" >> $env:GITHUB_STEP_SUMMARY
        } else {
          Write-Host "‚ùå Failed to generate appcast.json"
          exit 1
        }
      shell: pwsh

    - name: Generate release notes
      run: |
        $version = "${{ steps.version.outputs.version }}"

        @"
        ## Baketa $version

        ### Downloads

        | File | Description |
        |------|-------------|
        | ``Baketa-$version.zip`` | Main application (Windows x64, self-contained) |
        | ``appcast.json`` | Auto-update manifest (for existing installations) |

        ### Installation

        1. Download ``Baketa-$version.zip``
        2. Extract to desired location
        3. Run ``Baketa.UI.exe``
        4. On first run, required components will be downloaded automatically from [Model Assets v1](https://github.com/koizumiiiii/Baketa/releases/tag/models-v1)

        ### Auto-Update (New in this release!)

        Baketa now supports automatic updates. When a new version is available:
        - You'll see an update notification on startup
        - Click to download and install the update automatically
        - The application will restart with the new version

        ### Auto-Downloaded Components (from models-v1)

        The following components are downloaded automatically on first run:
        - **BaketaTranslationServer.zip** (~50MB) - NLLB-200 translation server
        - **BaketaSuryaOcrServer.zip** (~174MB) - Surya OCR server
        - **surya-detection-onnx.zip** (~31MB) - Detection model (ONNX INT8)
        - **surya-recognition-quantized.zip** (~665MB) - Recognition model (Quantized PyTorch)
        - **nllb-200-distilled-600M-ct2.zip** (~1.1GB) - Translation model

        ### System Requirements

        - Windows 10/11 (x64)
        - Internet connection (for first-time setup and auto-updates)
        - ~4GB disk space (including auto-downloaded components)
        "@ | Out-File -FilePath "release_notes.md" -Encoding utf8

    - name: Create Release
      uses: softprops/action-gh-release@v2
      with:
        name: "Baketa ${{ steps.version.outputs.version }}"
        body_path: release_notes.md
        files: |
          ./publish/Baketa-${{ steps.version.outputs.version }}.zip
          ./publish/appcast.json
        prerelease: ${{ steps.version.outputs.is-prerelease == 'true' }}
        make_latest: ${{ steps.version.outputs.is-prerelease == 'false' }}
        fail_on_unmatched_files: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
