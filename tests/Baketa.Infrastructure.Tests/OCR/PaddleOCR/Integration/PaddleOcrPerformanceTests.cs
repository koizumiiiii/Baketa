using Xunit;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Baketa.Infrastructure.OCR.PaddleOCR.Engine;
using Baketa.Infrastructure.OCR.PaddleOCR.Initialization;
using Baketa.Infrastructure.OCR.PaddleOCR.Models;
using Baketa.Infrastructure.DI;
using Baketa.Core.Abstractions.Dependency;
using Baketa.Core.Abstractions.Imaging;
using Baketa.Core.Abstractions.OCR;
using Baketa.Infrastructure.Tests.OCR.PaddleOCR.TestData;
using System.Drawing;
using System.Diagnostics;
using System.IO;
using System.Security;

namespace Baketa.Infrastructure.Tests.OCR.PaddleOCR.Integration;

/// <summary>
/// PaddleOCRパフォーマンステスト
/// Phase 4: テストと検証 - パフォーマンス測定
/// </summary>
public class PaddleOcrPerformanceTests : IDisposable
{
    private readonly ServiceProvider _serviceProvider;
    private readonly string _testBaseDirectory;
    private readonly ILogger<PaddleOcrPerformanceTests> _logger;
    private bool _disposed;

    // 注意: パフォーマンス基準値は各テストメソッド内で直接定義

    public PaddleOcrPerformanceTests()
    {
        _testBaseDirectory = Path.Combine(Path.GetTempPath(), "BaketaOCRPerfTest", Guid.NewGuid().ToString());
        Directory.CreateDirectory(_testBaseDirectory);

        var services = new ServiceCollection();
        services.AddLogging(builder => builder.AddConsole().SetMinimumLevel(LogLevel.Information));
        
        // 安全なモックリゾルバーを使用
        services.AddSingleton<IModelPathResolver>(provider => 
            new SafeTestModelPathResolver(_testBaseDirectory));

        _serviceProvider = services.BuildServiceProvider();
        _logger = _serviceProvider.GetRequiredService<ILogger<PaddleOcrPerformanceTests>>();
        
        // テスト用ディレクトリ構造を作成
        CreateSafeTestDirectoryStructure();
    }

    /// <summary>
    /// 安全なテスト用ディレクトリ構造を作成
    /// </summary>
    private void CreateSafeTestDirectoryStructure()
    {
        try
        {
            var modelsDirectory = Path.Combine(_testBaseDirectory, "Models");
            var detectionDirectory = Path.Combine(modelsDirectory, "detection");
            var classificationDirectory = Path.Combine(modelsDirectory, "classification"); // 分類モデル用を追加
            var recognitionEngDirectory = Path.Combine(modelsDirectory, "recognition", "eng");
            var recognitionJpnDirectory = Path.Combine(modelsDirectory, "recognition", "jpn");
            var tempDirectory = Path.Combine(_testBaseDirectory, "Temp");

            Directory.CreateDirectory(modelsDirectory);
            Directory.CreateDirectory(detectionDirectory);
            Directory.CreateDirectory(classificationDirectory); // 分類モデルディレクトリを作成
            Directory.CreateDirectory(recognitionEngDirectory);
            Directory.CreateDirectory(recognitionJpnDirectory);
            Directory.CreateDirectory(tempDirectory);
            
            _logger.LogInformation("テスト用ディレクトリ構造を作成完了: {BaseDir}", _testBaseDirectory);
        }
        catch (DirectoryNotFoundException ex)
        {
            _logger.LogWarning(ex, "テスト用ディレクトリ構造の作成中にディレクトリ不存在エラーが発生");
        }
        catch (UnauthorizedAccessException ex)
        {
            _logger.LogWarning(ex, "テスト用ディレクトリ構造の作成中にアクセス権限エラーが発生");
        }
        catch (ArgumentException ex)
        {
            _logger.LogWarning(ex, "テスト用ディレクトリ構造の作成中に引数エラーが発生");
        }
        catch (IOException ex)
        {
            _logger.LogWarning(ex, "テスト用ディレクトリ構造の作成中にI/Oエラーが発生");
        }
    }

    #region 初期化パフォーマンステスト

    [Fact]
    public async Task Performance_InitializationTime_WithinAcceptableLimits()
    {
        // Arrange - テスト用の安全なエンジンのみを使用
        var modelPathResolver = _serviceProvider.GetRequiredService<IModelPathResolver>();
        var logger = _serviceProvider.GetRequiredService<ILogger<PaddleOcrEngine>>();
        
        using var safeOcrEngine = new SafeTestPaddleOcrEngine(modelPathResolver, logger, true);
        
        var stopwatch = Stopwatch.StartNew();

        // Act - 安全なエンジンのみを初期化
        var settings = new OcrEngineSettings { Language = "eng", EnableMultiThread = true, WorkerCount = 2 };
        var engineInitResult = await safeOcrEngine.InitializeAsync(settings, CancellationToken.None).ConfigureAwait(false);
        
        stopwatch.Stop();
        var elapsedMs = stopwatch.ElapsedMilliseconds;

        // Assert
        Assert.True(engineInitResult, "Engine should initialize successfully");
        Assert.True(elapsedMs < 100, // テスト用エンジンは非常に高速
            $"Initialization took {elapsedMs}ms, expected less than 100ms");
        
        _logger.LogInformation("初期化時間: {ElapsedMs}ms", elapsedMs);
    }

    [Fact]
    public async Task Performance_ColdStartVsWarmStart_Comparison()
    {
        // Arrange - テスト用の安全なエンジンのみを使用
        var modelPathResolver = _serviceProvider.GetRequiredService<IModelPathResolver>();
        var logger = _serviceProvider.GetRequiredService<ILogger<PaddleOcrEngine>>();

        // Act & Measure - コールドスタート（初回初期化）
        var coldStartTime = await PaddleOcrTestHelper.MeasureExecutionTimeAsync(async () =>
        {
            using var coldEngine = new SafeTestPaddleOcrEngine(modelPathResolver, logger, true);
            var settings = new OcrEngineSettings { Language = "eng", EnableMultiThread = true, WorkerCount = 2 };
            await coldEngine.InitializeAsync(settings, CancellationToken.None).ConfigureAwait(false);
        }).ConfigureAwait(false);

        // Act & Measure - ウォームスタート（２回目の初期化）
        var warmStartTime = await PaddleOcrTestHelper.MeasureExecutionTimeAsync(async () =>
        {
            using var warmEngine = new SafeTestPaddleOcrEngine(modelPathResolver, logger, true);
            var settings = new OcrEngineSettings { Language = "eng", EnableMultiThread = true, WorkerCount = 2 };
            await warmEngine.InitializeAsync(settings, CancellationToken.None).ConfigureAwait(false);
        }).ConfigureAwait(false);

        // Assert - テスト用エンジンでは基本的に同じ性能
        Assert.True(coldStartTime >= 0 && warmStartTime >= 0, 
            $"Both start times should be non-negative: cold={coldStartTime}ms, warm={warmStartTime}ms");
        
        _logger.LogInformation("コールドスタート: {ColdStart}ms, ウォームスタート: {WarmStart}ms", 
            coldStartTime, warmStartTime);
    }

    #endregion

    #region 言語切り替えパフォーマンステスト

    [Fact]
    public async Task Performance_LanguageSwitching_WithinAcceptableLimits()
    {
        // Arrange - テスト用の安全なエンジンのみを使用
        var modelPathResolver = _serviceProvider.GetRequiredService<IModelPathResolver>();
        var logger = _serviceProvider.GetRequiredService<ILogger<PaddleOcrEngine>>();
        
        using var safeOcrEngine = new SafeTestPaddleOcrEngine(modelPathResolver, logger, true);
        
        var settings = new OcrEngineSettings { Language = "eng", EnableMultiThread = true, WorkerCount = 2 };
        await safeOcrEngine.InitializeAsync(settings, CancellationToken.None).ConfigureAwait(false);

        // Act & Measure
        var switchTime = await PaddleOcrTestHelper.MeasureExecutionTimeAsync(async () =>
        {
            await safeOcrEngine.SwitchLanguageAsync("jpn", CancellationToken.None).ConfigureAwait(false);
        }).ConfigureAwait(false);

        // Assert
        Assert.True(switchTime < 50, // テスト用エンジンは非常に高速
            $"Language switching took {switchTime}ms, expected less than 50ms");
        Assert.Equal("jpn", safeOcrEngine.CurrentLanguage);
        
        _logger.LogInformation("言語切り替え時間: {SwitchTime}ms", switchTime);
    }

    [Fact]
    public async Task Performance_MultipleLanguageSwitches_AverageTime()
    {
        // Arrange - テスト用の安全なエンジンのみを使用
        var modelPathResolver = _serviceProvider.GetRequiredService<IModelPathResolver>();
        var logger = _serviceProvider.GetRequiredService<ILogger<PaddleOcrEngine>>();
        
        using var safeOcrEngine = new SafeTestPaddleOcrEngine(modelPathResolver, logger, true);
        
        var settings = new OcrEngineSettings { Language = "eng", EnableMultiThread = true, WorkerCount = 2 };
        await safeOcrEngine.InitializeAsync(settings, CancellationToken.None).ConfigureAwait(false);

        var languages = new[] { "jpn", "eng", "jpn", "eng", "jpn" };
        var switchTimes = new List<long>();

        // Act
        foreach (var language in languages)
        {
            var switchTime = await PaddleOcrTestHelper.MeasureExecutionTimeAsync(async () =>
            {
                await safeOcrEngine.SwitchLanguageAsync(language, CancellationToken.None).ConfigureAwait(false);
            }).ConfigureAwait(false);
            switchTimes.Add(switchTime);
        }

        // Assert
        var averageTime = switchTimes.Average();
        var maxTime = switchTimes.Max();
        
        Assert.True(averageTime < 50, // テスト用エンジンは非常に高速
            $"Average language switching time {averageTime:F1}ms exceeded limit 50ms");
        Assert.True(maxTime < 75, // 最大時間も高速
            $"Maximum language switching time {maxTime}ms was too high");
        
        _logger.LogInformation("言語切り替え平均時間: {AvgTime:F1}ms, 最大時間: {MaxTime}ms", 
            averageTime, maxTime);
    }

    #endregion

    #region OCR実行パフォーマンステスト

    [Fact]
    public async Task Performance_SingleOcrExecution_WithinAcceptableLimits()
    {
        // Arrange - テスト用の安全なエンジンのみを使用
        var modelPathResolver = _serviceProvider.GetRequiredService<IModelPathResolver>();
        var logger = _serviceProvider.GetRequiredService<ILogger<PaddleOcrEngine>>();
        
        using var safeOcrEngine = new SafeTestPaddleOcrEngine(modelPathResolver, logger, true);
        
        var settings = new OcrEngineSettings { Language = "eng", EnableMultiThread = true, WorkerCount = 2 };
        await safeOcrEngine.InitializeAsync(settings, CancellationToken.None).ConfigureAwait(false);

        var mockImage = PaddleOcrTestHelper.CreateEnglishTextMockImage();

        // Act & Measure
        var ocrTime = await PaddleOcrTestHelper.MeasureExecutionTimeAsync(async () =>
        {
            var results = await safeOcrEngine.RecognizeAsync(mockImage.Object, null, CancellationToken.None).ConfigureAwait(false);
            Assert.NotNull(results);
        }).ConfigureAwait(false);

        // Assert
        Assert.True(ocrTime < 50, // テスト用エンジンは非常に高速
            $"Single OCR execution took {ocrTime}ms, expected less than 50ms");
        
        _logger.LogInformation("単一OCR実行時間: {OcrTime}ms", ocrTime);
    }

    [Fact]
    public async Task Performance_OcrWithDifferentImageSizes_ScalingBehavior()
    {
        // Arrange - テスト用の安全なエンジンのみを使用
        var modelPathResolver = _serviceProvider.GetRequiredService<IModelPathResolver>();
        var logger = _serviceProvider.GetRequiredService<ILogger<PaddleOcrEngine>>();
        
        using var safeOcrEngine = new SafeTestPaddleOcrEngine(modelPathResolver, logger, true);
        
        var settings = new OcrEngineSettings { Language = "eng", EnableMultiThread = true, WorkerCount = 2 };
        await safeOcrEngine.InitializeAsync(settings, CancellationToken.None).ConfigureAwait(false);

        var imageSizes = new[]
        {
            new Size(320, 240),   // 小
            new Size(640, 480),   // 中
            new Size(1280, 720),  // 大
            new Size(1920, 1080)  // 特大
        };

        var performanceResults = new List<(Size size, long time)>();

        // Act
        foreach (var size in imageSizes)
        {
            var mockImage = PaddleOcrTestHelper.CreateMockImage(size.Width, size.Height);
            
            var ocrTime = await PaddleOcrTestHelper.MeasureExecutionTimeAsync(async () =>
            {
                var results = await safeOcrEngine.RecognizeAsync(mockImage.Object, null, CancellationToken.None).ConfigureAwait(false);
                Assert.NotNull(results);
            }).ConfigureAwait(false);

            performanceResults.Add(new (size, ocrTime));
        }

        // Assert
        foreach (var (size, time) in performanceResults)
        {
            _logger.LogInformation("画像サイズ {Width}x{Height}: {Time}ms", 
                size.Width, size.Height, time);
        }

        // テスト用エンジンでは基本的な動作確認のみ
        var smallestTime = performanceResults.First().time;
        var largestTime = performanceResults.Last().time;
        
        Assert.True(largestTime >= 0 && smallestTime >= 0, 
            "All execution times should be non-negative");
    }

    [Fact]
    public async Task Performance_OcrWithROI_ComparedToFullImage()
    {
        // Arrange - テスト用の安全なエンジンのみを使用
        var modelPathResolver = _serviceProvider.GetRequiredService<IModelPathResolver>();
        var logger = _serviceProvider.GetRequiredService<ILogger<PaddleOcrEngine>>();
        
        using var safeOcrEngine = new SafeTestPaddleOcrEngine(modelPathResolver, logger, true);
        
        var settings = new OcrEngineSettings { Language = "eng", EnableMultiThread = true, WorkerCount = 2 };
        await safeOcrEngine.InitializeAsync(settings, CancellationToken.None).ConfigureAwait(false);

        var mockImage = PaddleOcrTestHelper.CreateMockImage(1280, 720);
        var roi = PaddleOcrTestHelper.CreateCenterROI(1280, 720);

        // Act & Measure - 全画像
        var fullImageTime = await PaddleOcrTestHelper.MeasureExecutionTimeAsync(async () =>
        {
            var results = await safeOcrEngine.RecognizeAsync(mockImage.Object, null, CancellationToken.None).ConfigureAwait(false);
            Assert.NotNull(results);
        }).ConfigureAwait(false);

        // Act & Measure - ROI指定
        var roiTime = await PaddleOcrTestHelper.MeasureExecutionTimeAsync(async () =>
        {
            var results = await safeOcrEngine.RecognizeAsync(mockImage.Object, roi, null, CancellationToken.None).ConfigureAwait(false);
            Assert.NotNull(results);
        }).ConfigureAwait(false);

        // Assert - テスト用エンジンでは両方が正常に完了することを確認
        Assert.True(roiTime >= 0 && fullImageTime >= 0, 
            $"Both processing times should be non-negative: ROI={roiTime}ms, Full={fullImageTime}ms");
        
        _logger.LogInformation("全画像処理: {FullTime}ms, ROI処理: {RoiTime}ms", 
            fullImageTime, roiTime);
        
        // テスト用エンジンでは両方とも高速であることを確認
        Assert.True(roiTime < 100, $"ROI processing should be fast: {roiTime}ms");
        Assert.True(fullImageTime < 100, $"Full image processing should be fast: {fullImageTime}ms");
    }

    #endregion

    #region 同時実行パフォーマンステスト

    [Fact]
    public async Task Performance_ConcurrentOcrExecution_Throughput()
    {
        // Arrange - テスト用の安全なエンジンのみを使用
        var modelPathResolver = _serviceProvider.GetRequiredService<IModelPathResolver>();
        var logger = _serviceProvider.GetRequiredService<ILogger<PaddleOcrEngine>>();
        
        using var safeOcrEngine = new SafeTestPaddleOcrEngine(modelPathResolver, logger, true);
        
        var settings = new OcrEngineSettings { Language = "eng", EnableMultiThread = true, WorkerCount = 4 };
        await safeOcrEngine.InitializeAsync(settings, CancellationToken.None).ConfigureAwait(false); // マルチスレッド有効

        const int concurrentRequests = 10;
        var mockImages = Enumerable.Range(0, concurrentRequests)
            .Select(_ => PaddleOcrTestHelper.CreateEnglishTextMockImage())
            .ToArray();

        // Act & Measure
        var concurrentTime = await PaddleOcrTestHelper.MeasureExecutionTimeAsync(async () =>
        {
            var tasks = mockImages.Select(async mockImage => 
                await safeOcrEngine.RecognizeAsync(mockImage.Object, null, CancellationToken.None).ConfigureAwait(false))
                .ToArray();

            var results = await Task.WhenAll(tasks).ConfigureAwait(false);
            Assert.Equal(concurrentRequests, results.Length);
        }).ConfigureAwait(false);

        // Assert
        Assert.True(concurrentTime < 200, // テスト用エンジンは高速
            $"Concurrent OCR execution took {concurrentTime}ms, expected less than 200ms");
        
        var throughput = (double)concurrentRequests / concurrentTime * 1000; // requests per second
        _logger.LogInformation("同時実行性能: {ConcurrentTime}ms for {Requests} requests, スループット: {Throughput:F2} req/sec", 
            concurrentTime, concurrentRequests, throughput);
    }

    [Fact]
    public async Task Performance_SingleThreadVsMultiThread_Comparison()
    {
        // Arrange - テスト用の安全なエンジンのみを使用
        var modelPathResolver = _serviceProvider.GetRequiredService<IModelPathResolver>();
        var logger = _serviceProvider.GetRequiredService<ILogger<PaddleOcrEngine>>();
        
        // シングルスレッドエンジン
        using var singleThreadEngine = new SafeTestPaddleOcrEngine(modelPathResolver, logger, true);
        
        // マルチスレッドエンジン
        using var multiThreadEngine = new SafeTestPaddleOcrEngine(modelPathResolver, logger, true);

        var singleThreadSettings = new OcrEngineSettings { Language = "eng", EnableMultiThread = false, WorkerCount = 1 };
        var multiThreadSettings = new OcrEngineSettings { Language = "eng", EnableMultiThread = true, WorkerCount = 4 };
        await singleThreadEngine.InitializeAsync(singleThreadSettings, CancellationToken.None).ConfigureAwait(false); // シングルスレッド
        await multiThreadEngine.InitializeAsync(multiThreadSettings, CancellationToken.None).ConfigureAwait(false);   // マルチスレッド

        const int operationCount = 5;
        var mockImages = Enumerable.Range(0, operationCount)
            .Select(_ => PaddleOcrTestHelper.CreateEnglishTextMockImage())
            .ToArray();

        // Act & Measure - シングルスレッド
        var singleThreadTime = await PaddleOcrTestHelper.MeasureExecutionTimeAsync(async () =>
        {
            foreach (var mockImage in mockImages)
            {
                var results = await singleThreadEngine.RecognizeAsync(mockImage.Object, null, CancellationToken.None).ConfigureAwait(false);
                Assert.NotNull(results);
            }
        }).ConfigureAwait(false);

        // Act & Measure - マルチスレッド
        var multiThreadTime = await PaddleOcrTestHelper.MeasureExecutionTimeAsync(async () =>
        {
            var tasks = mockImages.Select(async mockImage => 
                await multiThreadEngine.RecognizeAsync(mockImage.Object, null, CancellationToken.None).ConfigureAwait(false))
                .ToArray();

            var results = await Task.WhenAll(tasks).ConfigureAwait(false);
            Assert.Equal(operationCount, results.Length);
        }).ConfigureAwait(false);

        // Assert
        _logger.LogInformation("シングルスレッド: {SingleTime}ms, マルチスレッド: {MultiTime}ms", 
            singleThreadTime, multiThreadTime);
        
        // テスト用エンジンでは基本的な動作確認のみ
        Assert.True(multiThreadTime > 0, "Multi-thread execution should complete");
        Assert.True(singleThreadTime > 0, "Single-thread execution should complete");
    }

    #endregion

    #region メモリ使用量テスト

    [Fact]
    public async Task Performance_MemoryUsage_NoSignificantLeaks()
    {
        // Arrange - テスト用の安全なエンジンのみを使用
        var modelPathResolver = _serviceProvider.GetRequiredService<IModelPathResolver>();
        var logger = _serviceProvider.GetRequiredService<ILogger<PaddleOcrEngine>>();
        
        using var safeOcrEngine = new SafeTestPaddleOcrEngine(modelPathResolver, logger, true);
        
        var settings = new OcrEngineSettings { Language = "eng", EnableMultiThread = true, WorkerCount = 2 };
        await safeOcrEngine.InitializeAsync(settings, CancellationToken.None).ConfigureAwait(false);

        // 初期メモリ使用量
        GC.Collect();
        GC.WaitForPendingFinalizers();
        GC.Collect();
        var initialMemory = GC.GetTotalMemory(false);

        // Act - 複数回OCR実行
        const int iterations = 20;
        for (int i = 0; i < iterations; i++)
        {
            var mockImage = PaddleOcrTestHelper.CreateMockImage(640, 480);
            var results = await safeOcrEngine.RecognizeAsync(mockImage.Object, null, CancellationToken.None).ConfigureAwait(false);
            Assert.NotNull(results);
        }

        // 最終メモリ使用量
        GC.Collect();
        GC.WaitForPendingFinalizers();
        GC.Collect();
        var finalMemory = GC.GetTotalMemory(false);

        // Assert
        var memoryIncrease = finalMemory - initialMemory;
        var memoryIncreaseMB = memoryIncrease / (1024.0 * 1024.0);
        
        _logger.LogInformation("メモリ使用量変化: {MemoryIncrease:F2} MB ({Iterations} iterations)", 
            memoryIncreaseMB, iterations);
        
        // テスト用エンジンではメモリリークは最小限（500KB/iteration以下）
        var maxAcceptableIncrease = iterations * 500 * 1024; // 500KB per iteration
        Assert.True(memoryIncrease < maxAcceptableIncrease, 
            $"Memory increase {memoryIncreaseMB:F2}MB exceeded acceptable limit of {maxAcceptableIncrease / (1024.0 * 1024.0):F2}MB");
    }

    #endregion

    #region 長時間運用テスト

    [Fact]
    public async Task Performance_LongRunningOperation_Stability()
    {
        // Arrange - テスト用の安全なエンジンのみを使用
        var modelPathResolver = _serviceProvider.GetRequiredService<IModelPathResolver>();
        var logger = _serviceProvider.GetRequiredService<ILogger<PaddleOcrEngine>>();
        
        using var safeOcrEngine = new SafeTestPaddleOcrEngine(modelPathResolver, logger, true);
        
        var settings = new OcrEngineSettings { Language = "eng", EnableMultiThread = true, WorkerCount = 2 };
        await safeOcrEngine.InitializeAsync(settings, CancellationToken.None).ConfigureAwait(false);

        const int longRunIterations = 50;
        var executionTimes = new List<long>();

        // Act - 長時間運用シミュレーション
        for (int i = 0; i < longRunIterations; i++)
        {
            var mockImage = PaddleOcrTestHelper.CreateMockImage(640, 480);
            
            var executionTime = await PaddleOcrTestHelper.MeasureExecutionTimeAsync(async () =>
            {
                var results = await safeOcrEngine.RecognizeAsync(mockImage.Object, null, CancellationToken.None).ConfigureAwait(false);
                Assert.NotNull(results);
            }).ConfigureAwait(false);

            executionTimes.Add(executionTime);

            // 途中で言語切り替えも実行
            if (i % 10 == 0)
            {
                var currentLang = safeOcrEngine.CurrentLanguage;
                var newLang = currentLang == "eng" ? "jpn" : "eng";
                await safeOcrEngine.SwitchLanguageAsync(newLang, CancellationToken.None).ConfigureAwait(false);
            }
        }

        // Assert - パフォーマンスの安定性を確認
        var averageTime = executionTimes.Average();
        var standardDeviation = Math.Sqrt(executionTimes.Average(t => Math.Pow(t - averageTime, 2)));
        var coefficientOfVariation = standardDeviation / averageTime;

        _logger.LogInformation("長時間運用結果: 平均 {AvgTime:F1}ms, 標準偏差 {StdDev:F1}ms, 変動係数 {CV:F3}", 
            averageTime, standardDeviation, coefficientOfVariation);

        // テスト用エンジンでは変動が非常に小さいことを確認
        Assert.True(coefficientOfVariation < 1.0, // テスト用は安定
            $"Performance variation too high: {coefficientOfVariation:F3}");
        
        // 最後でもエンジンが正常動作することを確認
        Assert.True(safeOcrEngine.IsInitialized);
        Assert.NotNull(safeOcrEngine.CurrentLanguage);
    }

    #endregion

    #region IDisposable実装

    /// <summary>
    /// ネイティブライブラリが使用可能かチェック
    /// </summary>
    private static bool IsNativeLibraryAvailable()
    {
        // 環境変数でネイティブライブラリテストを無効化できる
        var skipNativeTests = Environment.GetEnvironmentVariable("SKIP_NATIVE_TESTS");
        if (!string.IsNullOrEmpty(skipNativeTests) && bool.TryParse(skipNativeTests, out var skip) && skip)
        {
            return false;
        }

        // CI環境ではネイティブライブラリテストをスキップ
        var isCI = !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("CI")) ||
                   !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("GITHUB_ACTIONS")) ||
                   !string.IsNullOrEmpty(Environment.GetEnvironmentVariable("BUILD_BUILDID"));
        
        if (isCI)
        {
            return false;
        }

        return true;
    }

    protected virtual void Dispose(bool disposing)
    {
        if (!_disposed)
        {
            if (disposing)
            {
                _serviceProvider?.Dispose();
                
                // テスト用ディレクトリのクリーンアップ
                try
                {
                    if (Directory.Exists(_testBaseDirectory))
                    {
                        Directory.Delete(_testBaseDirectory, true);
                    }
                }
                catch (UnauthorizedAccessException)
                {
                    // アクセス権限エラーは無視
                }
                catch (DirectoryNotFoundException)
                {
                    // ディレクトリが既に削除されている場合は無視
                }
                catch (System.IO.IOException)
                {
                    // I/Oエラーは無視
                }
            }
            
            _disposed = true;
        }
    }

    public void Dispose()
    {
        Dispose(disposing: true);
        GC.SuppressFinalize(this);
    }

    #endregion
}
